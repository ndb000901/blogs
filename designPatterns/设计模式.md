# 设计模式

设计模式通常分为三大类：**创建型模式**、**结构型模式**和**行为型模式**。每一类模式都解决了不同层次的设计问题。下面是每类设计模式的详细分类：

### 1. 创建型模式 (Creational Patterns)
这些模式主要关注对象的创建方式，目的是通过某种机制来实例化对象，避免直接使用 `new` 关键字。

- **单例模式 (Singleton)**：确保一个类只有一个实例，并提供全局访问。
- **工厂方法模式 (Factory Method)**：定义一个创建对象的接口，允许子类决定实例化哪一个类。
- **抽象工厂模式 (Abstract Factory)**：提供一个创建一系列相关或依赖对象的接口，而无需指定具体类。
- **建造者模式 (Builder)**：将复杂对象的构建过程分解，使得同样的构建过程可以创建不同的表示。
- **原型模式 (Prototype)**：通过复制现有的实例来创建新对象，而不是通过构造器。

### 2. 结构型模式 (Structural Patterns)
这些模式主要处理对象和类的组合，用于确保系统中的不同部分能高效地协作。

- **适配器模式 (Adapter)**：将一个类的接口转换成客户期望的另一个接口，使得原本不兼容的接口能够一起工作。
- **桥接模式 (Bridge)**：将抽象与实现解耦，使得两者可以独立变化。
- **组合模式 (Composite)**：将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。
- **装饰器模式 (Decorator)**：动态地给对象添加一些额外的职责，而不影响其他对象。
- **外观模式 (Facade)**：为复杂的子系统提供一个简单的接口，使得子系统更容易使用。
- **享元模式 (Flyweight)**：通过共享对象来有效地支持大量的细粒度对象。
- **代理模式 (Proxy)**：为其他对象提供一种代理，以控制对这个对象的访问。

### 3. 行为型模式 (Behavioral Patterns)
这些模式主要关注对象间的通信和职责分配，用于更好地控制对象之间的协作。

- **责任链模式 (Chain of Responsibility)**：通过多个处理对象来处理请求，使得请求沿着责任链传递，直到被处理。
- **命令模式 (Command)**：将请求封装为对象，从而使你可以用不同的请求对客户进行参数化，队列请求或记录请求日志。
- **解释器模式 (Interpreter)**：给定一个语言，定义它的文法，并提供一个解释器来解释语言中的句子。
- **迭代器模式 (Iterator)**：提供一种方法来顺序访问集合对象，而不暴露集合对象的内部表示。
- **中介者模式 (Mediator)**：用一个中介者来封装一组对象的交互，从而使得对象之间的交互变得更松耦合。
- **备忘录模式 (Memento)**：在不暴露对象实现细节的情况下，保存对象的状态，以便以后恢复。
- **观察者模式 (Observer)**：当一个对象状态发生改变时，所有依赖于它的对象都会自动通知并更新。
- **状态模式 (State)**：允许一个对象在其内部状态改变时改变它的行为。
- **策略模式 (Strategy)**：定义一系列算法，将每一个算法封装起来，并使它们可以互换。
- **模板方法模式 (Template Method)**：定义一个操作中的算法框架，将一些步骤的实现延迟到子类中。
- **访问者模式 (Visitor)**：表示一个作用于某对象结构中的各个元素的操作，使你可以在不改变元素类的前提下定义新的操作。



touch 结构型-适配器模式.md
touch 结构型-桥接模式.md
touch 结构型-组合模式.md
touch 结构型-装饰器模式.md
touch 结构型-外观模式.md
touch 结构型-享元模式.md
touch 结构型-代理模式.md


touch 行为型-责任链模式.md
touch 行为型-命令模式.md
touch 行为型-解释器模式.md
touch 行为型-迭代器模式.md
touch 行为型-中介者模式.md
touch 行为型-备忘录模式.md
touch 行为型-观察者模式.md
touch 行为型-状态模式.md
touch 行为型-策略模式.md
touch 行为型-模板方法模式.md
touch 行为型-访问者模式.md