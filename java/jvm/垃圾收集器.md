# 垃圾收集器详解

HotSpot JVM 提供了多种垃圾收集器（GC），主要分为 **串行（Serial）、并行（Parallel）、CMS（Concurrent Mark-Sweep）、G1（Garbage First）、ZGC、Shenandoah** 等。不同 GC 适用于不同的应用场景，下面是详细解析。

---

## **1. 串行垃圾收集器（Serial GC）**
- **JVM 参数**：
  - `-XX:+UseSerialGC`
- **特点**：
  - 适用于小型应用（单线程环境）。
  - **STW（Stop-The-World）** 时间较长，但简单高效。
  - **新生代** 采用 **复制算法**，**老年代** 采用 **标记-整理算法**。
- **适用场景**：
  - **单 CPU 机器**，或者 **Client 端** 应用，如桌面应用。

---

## **2. 串行老年代垃圾收集器（Serial Old GC）**
- **JVM 参数**：
  - `-XX:+UseSerialOldGC`
- **特点**：
  - Serial GC 在老年代的实现。
  - 采用 **标记-整理（Mark-Compact）** 算法。
  - 适用于 **单线程环境**，主要配合 Serial GC 运行。
- **适用场景**：
  - **Client 端应用**，单 CPU 机器。

---

## **3. 并行垃圾收集器（Parallel GC，又称吞吐量 GC）**
- **JVM 参数**：
  - `-XX:+UseParallelGC`（新生代并行）
  - `-XX:+UseParallelOldGC`（老年代并行）
- **特点**：
  - 适用于 **多核 CPU 环境**，使用多线程进行 GC 操作。
  - 新生代使用 **复制算法**，老年代使用 **标记-整理算法**。
  - 主要目标是 **最大化吞吐量**（减少 GC 总时间，提高应用运行时间）。
- **适用场景**：
  - **批处理系统**，如大数据计算、后端服务，要求高吞吐。

---

## **4. 并行新生代垃圾收集器（ParNew GC）**
- **JVM 参数**：
  - `-XX:+UseParNewGC`
- **特点**：
  - **Parallel GC 在新生代的实现**，采用 **复制算法**。
  - 支持多线程并行收集，通常用于 **多核 CPU 环境**。
  - 适用于 **CMS GC**，因为 CMS 需要一个多线程的新生代 GC。
- **适用场景**：
  - 主要用于 **CMS GC** 组合，适用于低延迟应用。

---

## **5. 并行老年代垃圾收集器（Parallel Old GC）**
- **JVM 参数**：
  - `-XX:+UseParallelOldGC`
- **特点**：
  - **Parallel GC 在老年代的实现**。
  - 采用 **标记-整理（Mark-Compact）** 算法。
  - 提供高吞吐，适用于 **CPU 核心数较多的服务器**。
- **适用场景**：
  - **高吞吐量应用**，如批处理任务、大数据计算。

---

## **6. CMS（Concurrent Mark-Sweep）垃圾收集器**
- **JVM 参数**：
  - `-XX:+UseConcMarkSweepGC`
- **特点**：
  - 适用于 **低延迟应用**，并发执行 GC，减少 STW 时间。
  - 采用 **标记-清除（Mark-Sweep）** 算法。
  - 需要额外的 CPU 资源，且可能有 **碎片化问题**。
- **适用场景**：
  - 适用于 **低延迟、交互性强的应用**（如 Web 服务器、金融系统）。
- **缺点**：
  - **浮动垃圾问题**：并发清理时，用户线程还在运行，可能产生新的垃圾，导致 **晋升失败（Promotion Failure）** 触发 Full GC。
  - 需要 **预留 CPU 资源**，GC 线程可能与应用线程争抢 CPU 资源。

---

## **7. G1（Garbage First）垃圾收集器**
- **JVM 参数**：
  - `-XX:+UseG1GC`
- **特点**：
  - 适用于 **大堆内存**（如 4GB 以上）。
  - **Region 机制**：堆被划分为多个大小相等的 **Region**，不同 Region 充当 Eden、Survivor 或 Old 区。
  - 采用 **全局有序回收**，优先回收垃圾最多的 Region，提升效率。
  - 支持 **并发收集**，目标是控制 **GC 暂停时间**（如 `-XX:MaxGCPauseMillis=200`）。
- **适用场景**：
  - **大内存、高吞吐、低延迟的应用**。

---

## **8. ZGC（超低延迟垃圾收集器）**
- **JVM 参数**（JDK 11+）：
  - `-XX:+UseZGC`
- **特点**：
  - **几乎无 STW（< 10ms）**，GC 时间与堆大小无关，可支持 **TB 级内存**。
  - 采用 **Region + 并发标记 & 转移算法**，避免传统 GC STW 过长问题。
- **适用场景**：
  - **超大堆（>10GB）+ 低延迟的业务**，如 **金融交易、游戏、AI 计算**。

---

## **9. Shenandoah（低延迟 GC）**
- **JVM 参数**（JDK 12+）：
  - `-XX:+UseShenandoahGC`
- **特点**：
  - 主要目标是 **降低 STW 时间**，GC 时间不会随着堆大小增加。
  - 采用 **并发压缩（Concurrent Compacting）** 解决碎片问题。
  - 停顿时间一般低于 **10ms**。
- **适用场景**：
  - **大内存（>8GB）+ 低延迟应用**。

---

## **10.垃圾收集器选择建议**
| GC 类型 | 适用场景 | 特点 | 适用堆大小 |
|---------|---------|------|------------|
| **Serial GC** | 单线程应用 | STW 停顿较长 | 小于 1GB |
| **Parallel GC** | 吞吐量优先 | 充分利用多核 CPU | 1GB~8GB |
| **CMS GC** | 低延迟应用 | 并发收集，减少 STW | 2GB~16GB |
| **G1 GC** | 兼顾吞吐 & 低延迟 | 适用于大堆 | 4GB~32GB |
| **ZGC** | 超大内存低延迟 | 几乎无 STW，可扩展到 TB 级 | 10GB~TB 级 |
| **Shenandoah GC** | 低延迟应用 | 停顿时间短于 G1 | 8GB~TB 级 |

