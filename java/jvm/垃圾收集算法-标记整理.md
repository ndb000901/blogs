# 垃圾收集算法-标记整理(Mark-Compact)

**标记-整理（Mark-Compact）** 是一种**垃圾回收算法**，它结合了**标记（Mark）** 和 **整理（Compact）** 阶段，旨在**回收垃圾对象**的同时，**整理内存，避免内存碎片**。

与**标记-清除（Mark-Sweep）**算法相比，标记-整理不仅会**标记存活对象**，还会将存活对象移动到堆的一端，从而**解决了内存碎片化的问题**。

---

## **1. 标记-整理的工作原理**
标记-整理算法的流程包含两个阶段：

### 1. **标记阶段（Mark Phase）**
- 与标记-清除算法类似，**GC 会从 GC Root 开始**，通过遍历对象图，**标记所有存活的对象**。这部分的标记阶段与标记-清除算法相同。

### 2. **整理阶段（Compact Phase）**
- 标记阶段完成后，JVM 会遍历堆中的对象，将**存活对象移动到堆的一端**。这种移动会将**堆内的空闲区域集中在一端**，从而避免内存碎片。
- 由于对象的移动，堆内的内存会保持**连续性**，并且不会产生类似标记-清除算法中的**内存碎片**问题。

### **标记-整理算法的主要特点**
- **标记存活对象**，然后通过整理阶段将这些存活对象压缩到堆的一端。
- **清除**阶段通过移动存活对象来整理内存，**解决内存碎片化问题**。

---

## **2. 标记-整理的内存布局**
在标记-整理算法中，堆的内存布局会经历以下变化：

1. **GC前**：堆内存在大量存活对象和垃圾对象。
   - 存活对象分散在堆的各个位置。
   - 空闲内存块和已回收的内存块零散分布。

2. **GC过程中**：
   - **标记阶段**：通过从 GC Root 开始的对象引用链标记所有存活的对象。
   - **整理阶段**：将存活的对象移动到堆的一端，并压缩它们，从而**回收空闲内存**。

3. **GC后**：堆的内存被整理为紧凑的状态，不再有碎片。
   - 存活的对象都集中在堆的一端，另一端是连续的空闲内存。

---


## **3. 标记-整理的优缺点**

### **优点**
1. **解决内存碎片问题**：通过整理存活对象，标记-整理算法能够确保内存的连续性，避免了内存碎片化的困扰。
2. **提高内存利用率**：由于堆内存是紧凑的，后续对象分配可以更高效，避免了大量零散的内存块。
3. **对象移动**：所有存活对象都移动到了堆的一端，因此无需额外的空闲空间来存放新对象。

### **缺点**
1. **需要移动对象**：整理阶段需要遍历所有存活对象并将它们移动到堆的另一端。移动对象的成本较高，可能导致额外的性能开销。
2. **STW（Stop-The-World）时间较长**：由于对象移动和内存整理的过程较为复杂，可能会导致较长的 **Stop-The-World** 停顿时间，影响应用程序的响应性能。
3. **比标记-清除算法更复杂**：与简单的标记-清除算法相比，标记-整理需要额外的整理阶段，因此实现上更加复杂。
