# 垃圾收集算法-标记复制(Mark-Copy)

**标记-复制（Mark-Copy）** 是一种基于**分代垃圾回收**策略的算法，主要用于**新生代垃圾回收**。该算法通过**分配两个区域**来回收内存，并**通过复制存活对象**来减少**内存碎片**的问题，避免标记-清除算法的碎片化问题。

---

## **1. 标记-复制算法的工作原理**
标记-复制算法的基本流程可以分为两个阶段：

1. **标记（Mark）阶段**：
   - 在这个阶段，**JVM 会遍历所有可达的对象**（从GC Root开始），并**标记所有存活的对象**。
   - **可达的对象**是指从根对象（GC Root）可以通过引用链追踪到的对象。

2. **复制（Copy）阶段**：
   - 这个阶段将**标记为存活的对象**从**当前区域复制到另一个区域**（通常称为**目标区（To-space）**）。
   - 复制后，**原区域（From-space）中的所有对象都会被清除**，不再需要关心那些不存活的对象，避免了内存碎片问题。
   - 复制过程中，如果某个对象需要占用新的空间，它将被放入目标区，并且目标区是一个连续的内存块，从而避免了内存碎片。

---

## **2. 标记-复制的优点**
- **避免内存碎片**：因为新对象总是复制到目标区，所以在目标区内的对象都相对紧凑，不会产生碎片。
- **高效**：标记和复制两个阶段的操作都是**线性时间复杂度 O(n)**，效率较高。
- **简单实现**：相比于标记-清除算法，标记-复制算法在实现上更加简洁且高效。

---

## **3. 标记-复制的缺点**
- **内存使用效率低**：算法通常将堆分为**两个相等大小的区域**：一个是**当前使用区（From-space）**，另一个是**目标区（To-space）**。每次垃圾回收时，都会交换这两个区域。因此，只有一半的内存可以用于存储对象，另一半用于复制。这导致内存的使用效率较低，内存利用率为 **50%**。
  
- **需要额外的空间**：为了执行标记-复制算法，JVM 必须拥有两块内存区域：**From-space** 和 **To-space**，这可能导致需要额外的内存资源。


