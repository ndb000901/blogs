# 垃圾收集算法-标记清除(Mark-Sweep)

## **1. 标记-清除的基本流程**
该算法分为两个主要阶段：
1. **标记（Mark）阶段**：
   - 从 **GC Root（根对象）** 开始，遍历所有可达的对象，并 **标记它们为“存活”**。
   - **不可达对象不会被标记**，意味着它们已经**不可访问，等待清除**。

2. **清除（Sweep）阶段**：
   - 遍历整个堆，**回收未标记的对象**（即垃圾对象）。
   - 释放它们占用的内存，使其可用于后续的对象分配。

---


## **2. 标记-清除的优缺点**
### **优点**
1. **实现简单**：不需要移动对象，只是遍历并回收垃圾对象。
2. **不需要额外的空间**：不像 **标记-整理（Mark-Compact）** 和 **复制（Copying）** 算法那样需要额外的内存区域。

### **缺点**
1. **内存碎片化（Fragmentation）**：
   - 清除垃圾后，堆中可能存在**大量零散的内存块**，导致**大对象分配失败**，因为无法找到足够大的连续内存。
   - 例如：如果某个对象需要 1MB 内存，而堆中虽然有 2MB 空闲，但都是 **零散的小块**，对象仍然无法分配。
  
2. **标记和清除的开销大**：
   - 需要 **两次扫描整个堆**（一次标记，一次清除），执行效率较低。
  
3. **可能引起 STW（Stop-The-World）**：
   - GC 线程通常需要 **暂停所有应用线程**，标记和清除阶段都会导致程序**短暂卡顿**。

