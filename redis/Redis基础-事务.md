# Redis基础-事务

## 1. Redis 事务

Redis 事务是 Redis 提供的一种原子操作机制，用来将多个命令组合成一个执行单元。通过事务，多个 Redis 命令可以一次性执行，而不需要其他客户端干扰，保证事务内所有命令要么都执行，要么都不执行。

事务确保了多个命令的原子性，但是与传统的关系型数据库事务（如 MySQL）不同，Redis 事务并没有隔离性（隔离性较弱），也没有事务回滚机制（如出错时无法回滚）。

---

## 2. 事务原理

Redis 事务的工作方式如下：

1. **MULTI**：启动一个事务，Redis 会将接下来的命令放入事务队列中，而不立即执行。
2. **EXEC**：提交事务，所有在事务队列中的命令将按顺序执行。
3. **DISCARD**：取消事务，放入队列中的命令不会执行。
4. **WATCH**：用于实现乐观锁（乐观锁会在事务提交前检查是否有其他命令修改了某个键值，如果有则事务失败）。

事务内的命令会按顺序执行，且是原子的，即要么都执行，要么都不执行。

---

## 3. Redis 事务命令详解

### 3.1 **MULTI**：开启事务

```bash

MULTI
```

使用 `MULTI` 命令后，Redis 将进入事务模式，接下来执行的命令会被放入事务队列中，而不会立即执行。

示例：

```bash

MULTI
SET key1 value1
INCR key2
```

此时，`SET` 和 `INCR` 命令并没有被立即执行，它们会被排队。

### 3.2 **EXEC**：提交事务

```bash

EXEC
```

使用 `EXEC` 命令提交事务，Redis 会按顺序执行所有队列中的命令。

示例：

```bash

EXEC
```

此时，`SET` 和 `INCR` 命令将会执行。

### 3.3 **DISCARD**：放弃事务

```bash

DISCARD
```

使用 `DISCARD` 命令可以取消事务，不会执行事务队列中的命令。

示例：

```bash

DISCARD
```

### 3.4 **WATCH**：乐观锁（可选）

```bash

WATCH key1 [key2 ...]
```

`WATCH` 用于监视一个或多个键，如果这些键在事务执行前被其他客户端修改，`EXEC` 会返回 `nil`，表示事务执行失败。

示例：

```bash

WATCH key1
MULTI
SET key1 value1
EXEC
```

如果 `key1` 在 `MULTI` 和 `EXEC` 之间被修改，`EXEC` 将不会执行，返回 `nil`。

---

## 4. 事务的原子性

- 在 Redis 事务中，所有命令会一次性提交，保证原子性。
- 如果事务中的某个命令失败（比如语法错误、键值冲突），整个事务依然会执行完，Redis 不会回滚命令。

例如：

```bash

MULTI
SET key1 value1
INCR key1
EXEC
```

在这个例子中，即使 `INCR` 失败，`SET` 命令也会被执行。并且如果发生错误，事务不会回滚，其他命令会继续执行。

---

## 5. 事务的隔离性

Redis 事务不像传统关系型数据库那样提供**隔离性**。在 Redis 事务中：

- **事务中的命令执行顺序是严格按照队列中的顺序来执行**，但是没有事务隔离，其他客户端的命令仍然可以在事务执行过程中对 Redis 数据进行修改。
- Redis 不提供**锁机制**，因此事务的隔离性较弱，可能会有其他客户端在事务执行时修改相关的数据。

---

## 6. 事务与事务队列

事务命令会进入一个**事务队列**，而 Redis 会将所有命令执行完后一次性提交。

### 示例：事务队列的基本操作

```bash

MULTI
SET key1 value1
INCR key2
```

上面 `MULTI` 命令开始了一个事务，接下来的命令将不会立即执行，而是进入队列。

你可以使用 `MONITOR` 命令来查看 Redis 执行的操作。

```bash

MONITOR
```

在事务提交（`EXEC`）之前，Redis 不会执行这些命令，而是将它们排入队列。当执行 `EXEC` 后，Redis 执行队列中的命令。

---


