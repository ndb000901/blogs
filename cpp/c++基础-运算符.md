# c++基础-运算符


## 1. 算术运算符（Arithmetic Operators）

| 运算符 | 含义         | 示例         | 结果说明       |
|--------|--------------|--------------|----------------|
| `+`    | 加法         | `3 + 2`      | `5`            |
| `-`    | 减法         | `3 - 2`      | `1`            |
| `*`    | 乘法         | `3 * 2`      | `6`            |
| `/`    | 除法         | `3 / 2`      | `1`（整除）    |
| `%`    | 取模         | `3 % 2`      | `1`            |
| `++`   | 自增         | `++a` / `a++`| 加1，前后差异  |
| `--`   | 自减         | `--a` / `a--`| 减1，前后差异  |

> 注意：`%` 不能用于浮点类型；`/` 整除与浮点除法行为不同。

---

## 2. 关系运算符（Relational / Comparison Operators）

| 运算符 | 含义               | 示例       | 结果类型 |
|--------|--------------------|------------|-----------|
| `==`   | 相等比较           | `a == b`   | `true/false` |
| `!=`   | 不相等             | `a != b`   | `true/false` |
| `>`    | 大于               | `a > b`    | `true/false` |
| `<`    | 小于               | `a < b`    | `true/false` |
| `>=`   | 大于等于           | `a >= b`   | `true/false` |
| `<=`   | 小于等于           | `a <= b`   | `true/false` |

---

## 3. 逻辑运算符（Logical Operators）


| 运算符 | 含义         | 示例              | 说明                     |
|--------|--------------|-------------------|--------------------------|
| `&&`   | 逻辑与       | `a > 0 && b > 0`  | 全真才真，短路运算       |
| `\|\|`   | 逻辑或       | `a > 0 \|\| b > 0`  | 有真即真，短路运算       |
| `!`    | 逻辑非       | `!flag`           | 取反，非0为真            |

---

## 4. 位运算符（Bitwise Operators）

| 运算符 | 含义     | 示例         | 说明（以 `a = 5`, `b = 3`） |
|--------|----------|--------------|------------------------------|
| `&`    | 按位与   | `a & b`      | `0101 & 0011 = 0001`         |
| `\|`    | 按位或   | `a \| b`      | `0101 \| 0011 = 0111`         |
| `^`    | 按位异或 | `a ^ b`      | `0101 ^ 0011 = 0110`         |
| `~`    | 按位取反 | `~a`         | 对每位取反                   |
| `<<`   | 左移     | `a << 1`     | 相当于乘以 2^1 = 10          |
| `>>`   | 右移     | `a >> 1`     | 相当于除以 2^1 = 2           |

---

## 5. 赋值运算符（Assignment Operators）

| 运算符  | 含义             | 示例         | 等价形式        |
|---------|------------------|--------------|-----------------|
| `=`     | 赋值             | `x = 5`      | -               |
| `+=`    | 加后赋值         | `x += 2`     | `x = x + 2`     |
| `-=`    | 减后赋值         | `x -= 2`     | `x = x - 2`     |
| `*=`    | 乘后赋值         | `x *= 2`     | `x = x * 2`     |
| `/=`    | 除后赋值         | `x /= 2`     | `x = x / 2`     |
| `%=`    | 取模后赋值       | `x %= 2`     | `x = x % 2`     |
| `&= \|= ^= <<= >>=` | 位运算后赋值 | 同上类推 ||

---

## 6. 条件（三目）运算符（Ternary Operator）

| 运算符 | 含义      | 示例                  | 说明                 |
|--------|-----------|-----------------------|----------------------|
| `?:`   | 条件判断  | `a > b ? a : b`       | 条件真则取 a，否则 b |

---

## 7. 逗号运算符（Comma Operator）

| 运算符 | 含义      | 示例                    | 说明                           |
|--------|-----------|-------------------------|--------------------------------|
| `,`    | 多表达式  | `x = (a = 3, a + 2)`    | 执行多个表达式，返回最后结果   |

---

## 8. 指针运算符（Pointer Operators）

| 运算符 | 含义         | 示例         | 说明                     |
|--------|--------------|--------------|--------------------------|
| `*`    | 解引用       | `*ptr`       | 访问指针指向的内容       |
| `&`    | 取地址       | `&x`         | 获取变量 x 的地址        |
| `->`   | 访问指针成员 | `ptr->name`  | 等价于 `(*ptr).name`     |
| `->*`  | 指向成员指针 | `obj->*ptr`  | 类成员指针（高级用法）   |

---

## 9. 内存运算符（Memory Operators）

| 运算符     | 含义           | 示例                     | 说明                        |
|------------|----------------|--------------------------|-----------------------------|
| `new`      | 分配对象内存   | `int* p = new int(5);`   | 调用构造函数                |
| `delete`   | 释放对象内存   | `delete p;`              | 调用析构函数                |
| `new[]`    | 分配数组内存   | `int* a = new int[10];`  | 分配多个元素                |
| `delete[]` | 释放数组内存   | `delete[] a;`            | 调用多个析构函数            |

---

## 10. 类型转换运算符（Type Cast Operators）

| 运算符             | 含义             | 示例                             | 用途                         |
|--------------------|------------------|----------------------------------|------------------------------|
| `static_cast<T>()` | 编译期安全转换   | `static_cast<double>(i)`         | int→double，父子类间转换     |
| `dynamic_cast<T>()`| RTTI 运行时检查  | `dynamic_cast<Derived*>(base)`   | 多态类安全向下转型           |
| `const_cast<T>()`  | 修改 const 性质  | `const_cast<char*>(p)`           | 移除常量性                   |
| `reinterpret_cast<T>()`| 位模式强转 | `reinterpret_cast<int*>(p)`      | 不安全，位级别转换           |


### 10.1 C++ 类型转换分类总览

| 转换方式          | 关键字             | 类型           | 安全性 | 是否C++专有 | 用途简述                         |
|-------------------|--------------------|----------------|--------|-----|----------------------------------|
| 隐式转换          | 无（编译器自动）   | 编译器行为     | 一般安全 | 否  | 如 `int` 自动转为 `double`      |
| `static_cast`     | `static_cast<T>`   | 显式转换       | 较安全 | 是  | 编译期转换，类型兼容可用        |
| `const_cast`      | `const_cast<T>`    | 显式转换       | 小心用 | 是  | 去除/添加 `const/volatile` 修饰 |
| `reinterpret_cast`| `reinterpret_cast<T>` | 显式转换   | 不安全 | 是  | 强制转换地址，极限用法          |
| `dynamic_cast`    | `dynamic_cast<T>`  | 运行时类型检查 | 安全   | 是  | 多态类型转换，用于 RTTI         |
| C风格转换         | `(T)expr` 或 `T(expr)` | 显式     | 不安全 | 否  | 混合了上面几种，推荐替代掉     |

---

### 10.2 隐式转换（implicit conversion）

#### 📌 示例：
```cpp
int a = 10;
double d = a;  // int 自动转换为 double
```

- 编译器自动处理的类型转换
- 通常发生在：
  - 不同类型算术运算
  - 函数参数传递
  - 赋值语句中

---

### 10.3 `static_cast<T>()` — 编译期安全转换

| 特点               | 说明                                    |
|--------------------|-----------------------------------------|
| 编译期检查         | 转换类型必须兼容                        |
| 可用于数值类型转换 | 如 `double -> int`、`void* -> T*` 等     |
| 可用于基类/子类间转换 | 无虚函数时也能转                       |

#### 示例：
```cpp
double d = 3.14;
int i = static_cast<int>(d);  // 安全截断
```

```cpp
class Base {};
class Derived : public Base {};
Base* b = new Derived;
Derived* d = static_cast<Derived*>(b);  // OK，但需自己保证实际类型
```

当使用 static_cast 将父类指针转换为子类指针时，需要自己保证父类指针实际上指向的是一个子类对象。

如果父类指针指向的仅仅是一个父类对象，那么将它强制转换为子类指针是不安全的，并且会导致未定义行为

使用 `static_cast` 可以避免运行时的类型检查，从而可能带来一些性能上的提升。

---

### 10.4 `const_cast<T>()` — 改变 const/volatile 限定

| 特点            | 说明                                |
|-----------------|-------------------------------------|
| 唯一能改变 const/volatile 限定的转换 | 非常危险          |
| 常用于与 C 兼容的老代码              | 如 C 函数参数不加 const |

#### 示例：
```cpp
void print(char* p) { std::cout << p; }

const char* msg = "hello";
print(const_cast<char*>(msg));  // 去掉 const 传参（非常危险）
```

> 修改被 `const` 修饰的对象是**未定义行为**，极力避免！

---

### 10.5 `reinterpret_cast<T>()` — 位级强制转换

| 特点         | 说明                                  |
|--------------|---------------------------------------|
| 完全忽略类型 | 直接把内存解释成另一种类型            |
| 非常不安全   | 常用于底层操作（如指针、内存映射）     |

#### 示例：
```cpp
int i = 65;
char* p = reinterpret_cast<char*>(&i);
std::cout << *p;  // 输出：A（ASCII 65）

uintptr_t addr = reinterpret_cast<uintptr_t>(p);  // 指针转整型
```

> 除非你在写底层库或驱动，不建议使用。

---

### 10.6 `dynamic_cast<T>()` — 多态类型转换（RTTI）

| 特点                | 说明                                      |
|---------------------|-------------------------------------------|
| 只能用于多态类型    | 即基类需至少一个虚函数                    |
| 安全性高            | 转换失败返回 `nullptr`（指针）或抛异常（引用） |

#### 示例（指针形式）：
```cpp
class Base { virtual void foo() {} };
class Derived : public Base {};

Base* b = new Derived;
Derived* d = dynamic_cast<Derived*>(b);  // OK

Base* b2 = new Base;
Derived* d2 = dynamic_cast<Derived*>(b2);  // 返回 nullptr
```

#### 示例（引用形式）：
```cpp
try {
    Base& b = *new Base;
    Derived& d = dynamic_cast<Derived&>(b);  // 抛异常 std::bad_cast
} catch (const std::bad_cast& e) {
    std::cout << "Bad cast: " << e.what();
}
```

> **注意**：需要开启 RTTI（默认开启），否则编译失败。
`dynamic_cast` 需要在运行时进行类型检查，以确定被转换的父类指针是否真的指向目标子类类型的对象。
---

### 10.7 C风格类型转换 `(T)expr` 或 `T(expr)`

| 特点          | 说明                                       |
|---------------|--------------------------------------------|
| 不推荐使用    | 因为行为不透明，可能是上面几种混合         |
| 易写错        | 可绕过编译检查造成未定义行为               |

### 示例：
```cpp
int a = (int)3.14;      // 相当于 static_cast<int>(3.14)
char* p = (char*)&a;    // 相当于 reinterpret_cast<char*>(&a)
```

> 推荐全部用 `C++ 风格` 替代（`static_cast` 等），更清晰安全。


---

## 11. 其他运算符（Other Useful Operators）

| 运算符   | 含义             | 示例             | 说明                    |
|----------|------------------|------------------|-------------------------|
| `sizeof` | 获取类型大小     | `sizeof(int)`    | 单位：字节              |
| `typeid` | 类型信息         | `typeid(x).name()`| 需要 `#include <typeinfo>` |
| `.`      | 成员访问         | `obj.name`       | 用于对象访问            |

