# c++基础-指针


## 1.指针

> 指针是一个**变量**，用于**存储另一个变量的内存地址**。

### 例子：
```cpp
int x = 42;
int* p = &x;  // p 指向 x 的地址
```

- `&x` 取地址
- `*p` 解引用，获取 p 所指向的值，即 `*p == 42`

---

## 2. 指针的基本语法

| 表达式 | 含义 |
|--------|------|
| `int* p;` | 定义一个整型指针 |
| `p = &x;` | 将 p 设置为指向 x 的地址 |
| `*p` | 访问 p 指向的值 |
| `&x` | 获取变量 x 的地址 |

### 示例：
```cpp
int a = 10;
int* ptr = &a;
std::cout << *ptr << std::endl;  // 输出 10
```

---

## 3. 指针和内存的关系

在 64 位系统中，指针本质上是 **8 字节地址值**。

```cpp
int a = 10;
int* p = &a;
```

| 变量名 | 值 | 地址（假设） |
|--------|----|--------------|
| a      | 10 | 0x1000       |
| p      | 0x1000 | 0x2000   |

---

## 4. 指针的常见类型

| 类型 | 含义 |
|------|------|
| `int*` | 指向 int 的指针 |
| `void*` | 通用指针（无法解引用） |
| `int**` | 指向 int 指针的指针（多级指针） |
| `int* const p` | 指针本身不可改，但可改值 |
| `const int* p` | 指向的值不可变，指针可变 |

---

## 5. 指针与数组

### 数组名是指针常量

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;

std::cout << *(p + 2);  // 输出 3
```

- `arr[i]` 等价于 `*(arr + i)`
- `p++` 实际跳过 `sizeof(int)` 个字节（通常 4 字节）

---

## 6. 指针作为函数参数

### 传地址，提高效率，同时可以修改实参：

```cpp
void increment(int* p) {
    (*p)++;
}

int main() {
    int a = 5;
    increment(&a);
    std::cout << a;  // 输出 6
}
```

---

## 7. 指针和动态内存（new/delete）

```cpp
int* p = new int(10);  // 堆上分配 int，值为 10
delete p;              // 释放内存
```

### 数组：
```cpp
int* arr = new int[5];
delete[] arr;
```

> 动态内存必须手动释放，否则内存泄露！

---

## 8. 指针与结构体/类

```cpp
struct Point {
    int x, y;
};

Point p = {1, 2};
Point* ptr = &p;

std::cout << ptr->x;  // 使用 -> 访问成员
```

---

## 9. 函数指针（高阶技巧）

```cpp
int add(int a, int b) {
    return a + b;
}

int (*func)(int, int) = add;
std::cout << func(2, 3);  // 输出 5
```

函数指针常用于：
- 回调机制
- 策略模式
- 插件化设计

---

## 10. nullptr 和空指针判断

### `nullptr` 是 C++11 引入的空指针类型：

```cpp
int* p = nullptr;
if (p == nullptr) { ... }  // 安全判断
```

优于早期的 `NULL` 或 `0`，防止类型混淆。

---

## 11. 智能指针（C++11）

替代原始指针，**自动释放内存**，防止内存泄露。

| 类型 | 特点 |
|------|------|
| `std::unique_ptr` | 独占式，不能拷贝 |
| `std::shared_ptr` | 引用计数，可共享 |
| `std::weak_ptr` | 弱引用，防止循环引用 |

### 示例：
```cpp
#include <memory>

std::unique_ptr<int> p = std::make_unique<int>(10);
// 自动释放，无需 delete
```

---

## 12. 常见指针错误和陷阱

| 问题 | 描述 |
|------|------|
| 野指针 | 指针未初始化或指向释放的内存 |
| 悬空指针 | 被 delete 后未置 nullptr |
| 指针越界 | 访问未定义区域 |
| 重复 delete | 会导致程序崩溃或行为未定义 |
| 忘记 delete | 内存泄漏 |

### 示例：
```cpp
int* p = new int(10);
delete p;
*p = 5;  // 悬空指针，未定义行为
```
