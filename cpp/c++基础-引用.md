# c++基础-引用

## 1. 引用（Reference）

引用是 **某个变量的别名**，是对变量的一个“符号链接”。

```cpp
int a = 10;
int& ref = a;  // ref 是 a 的引用
```

之后 `ref` 和 `a` 完全等价，操作 `ref` 就是在操作 `a`。

---

## 2. 引用的基本特性

| 特性             | 说明 |
|------------------|------|
| 必须初始化       | 引用声明时必须初始化一次 |
| 不可更改绑定对象 | 引用一旦绑定，不能再指向别的对象 |
| 不为 nullptr     | 没有“空引用”概念 |
| 内部实现是指针   | 编译器用指针语义实现引用 |

---

## 3. 引用的常见用法

### 3.1 作为函数参数：**避免拷贝，提高性能**
```cpp
void print(const std::string& str) {
    std::cout << str;
}
```
- 推荐用 `const T&` 传大型对象
- 避免复制构造，提高性能

### 3.2 作为函数返回值：**支持链式调用 / 修改原值**

```cpp
int& getElement(std::vector<int>& vec, int i) {
    return vec[i];
}
```
调用方可以直接修改原数组元素。

---

## 4. 引用分类

### 4.1 左值引用（Lvalue Reference）

```cpp
int a = 5;
int& r = a;   // 左值引用
```

只能绑定到具名变量（左值）。

---

### 4.2 常量引用（const Lvalue Reference）

```cpp
const int& r = 10;  // 合法：右值绑定到 const 引用
```

能接受：
- 左值
- 右值（临时对象）

编译器会生成临时变量绑定上去。

---

### 4.3 右值引用（Rvalue Reference）— C++11

```cpp
int&& rr = 100;
```

- 只能绑定右值（临时对象）
- 典型用途：**移动语义**、**完美转发**、**移动构造函数**

搭配 `std::move`：
```cpp
std::string a = "hello";
std::string b = std::move(a);  // 调用移动构造
```

---

## 5. 引用 VS 指针

| 区别         | 引用              | 指针              |
|--------------|-------------------|-------------------|
| 是否可为空   | 否                | 可以为 nullptr    |
| 是否可修改指向 | 否                | 是                 |
| 必须初始化   | 是                | 否                |
| 语法简洁     | 更简洁（无 `*`、`->`） | 使用 `*`、`->`  |

底层实现：引用通常是编译器生成的指针，但屏蔽了指针语法。

---

## 6. 底层原理（编译器视角）

```cpp
int a = 10;
int& r = a;
r = 20;
```

编译器转换为类似：
```cpp
int a = 10;
int* r = &a;
*r = 20;
```

> 引用是语法糖，编译器背后用指针做了替换。

---



## 7. 引用的陷阱与注意事项

- **不要返回局部变量的引用**
  ```cpp
  int& bad() {
      int x = 10;
      return x;  // 悬空引用
  }
  ```

- **不要绑定引用到被移动的对象上再使用**
  ```cpp
  std::string a = "abc";
  std::string&& b = std::move(a);
  std::cout << a;  // 未定义行为
  ```

---

## 8. 常见面试题

### Q1：为什么函数参数推荐用 `const T&`？
- 避免拷贝（节省开销）
- 保证只读语义
- 支持左值 + 右值

### Q2：引用可以为空吗？
- 不能，引用必须初始化
- 但可以通过“野指针”模拟出悬空引用（危险）

```cpp
int* ptr; // 野指针，未初始化
// ... 可能的一些操作，ptr 可能指向任何地方 ...
int& ref = *ptr; // 尝试让引用指向野指针所指的内存


int* p = new int(10);
int& r = *p;
delete p; // p 指向的内存被释放
// r 现在是一个悬空引用，因为它指向的内存不再有效
```
---
