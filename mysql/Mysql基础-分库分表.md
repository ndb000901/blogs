# Mysql基础-分库分表


MySQL 本身并不原生支持自动的**分库分表**功能，但在大数据量和高并发业务场景中，**分库分表**（Sharding）是非常常见的一种手段。

---

## 1. 为什么要分库分表？

### 1.1 数据量过大
- 单表数据超过**千万级**时，查询、插入、索引维护等性能开始明显下降。
- 单库文件（如 InnoDB 的 ibd 文件）过大，不利于备份和恢复。

### 1.2 高并发访问
- 同一库/表在并发高峰时成为**性能瓶颈**，读写压力无法分摊。

### 1.3 水平扩展
- 分库分表可以将数据存放在多台机器（水平扩展）上，提高可用性和处理能力。

---

## 2. 分库分表方式分类

### 2.1 分库 VS 分表
| 类型   | 概念                             | 示例                  |
|--------|----------------------------------|-----------------------|
| 分表   | 同一个库中拆分多个表            | user_00, user_01...   |
| 分库   | 拆分成多个库                    | db0.user，db1.user    |
| 分库分表 | 多库 + 多表                    | db0.user_00, db1.user_01 |

### 2.2 垂直拆分（Vertical Split）
- 按 **业务维度** 拆分，例如将订单和用户数据拆到不同库。
- 常用于解耦业务、隔离冷热数据。

### 2.3 水平拆分（Horizontal Split）
- 按主键或其他字段哈希/范围拆分，把**同一表的数据**拆到多个库/表中。
- 适合大数据量场景，常见于电商、金融等行业。

---

## 3. 分库分表策略

### 3.1 范围法（Range）
```sql
user_id 1~10w 存表 user_00  
user_id 10w~20w 存表 user_01  
```

### 3.2 哈希法（Hash）
```sql
表名 = 'user_' + (user_id % 8)
```
- 均匀分布，避免数据倾斜。
- 缺点：跨分片聚合操作不方便。

### 3.3 一致性哈希（Consistent Hash）
- 常用于动态增加节点场景，分布更稳定。

---

## 4. 分库分表后的开发痛点

| 问题 | 描述 |
|------|------|
| 跨分片查询 | 比如 `SELECT COUNT(*)`、`ORDER BY`、`JOIN` 无法直接跨库执行 |
| 跨表分页 | 不同表取数据再统一分页逻辑复杂 |
| 分布式事务 | 不同分片上的操作无法用 MySQL 原生事务，需使用 XA / TCC / SAGA |
| ID 唯一性 | 主键不能使用自增 ID，需用分布式 ID（如雪花算法） |
| 维护复杂度 | 路由逻辑、扩容迁移、监控等需专门处理 |

---

## 5. 分库分表方案实现

### 5.1 手动实现

- 封装数据访问层：
    - 写路由算法（按 user_id 映射到具体库/表）
    - 拼 SQL 动态路由
    - 聚合跨表结果

适合：表不多、业务清晰、开发有能力的场景。

### 5.2 中间件方案（推荐）

| 中间件 | 优点 | 备注 |
|--------|------|------|
| [ShardingSphere](https://shardingsphere.apache.org/) | 功能强，支持分库分表、分布式事务、分布式 ID | Java 生态好 |
| Cobar / TDDL（阿里） | 成熟稳定 | 淘宝使用 |
| MyCat | 开源，中间层代理数据库 | 社区支持一般 |
| Vitess（YouTube） | 高可用，云原生支持好 | K8s友好 |

---

## 6. 分布式 ID 生成方案

由于不能用自增主键，常用如下几种方式生成全局唯一 ID：

| 名称 | 特点 |
|------|------|
| 雪花算法（Snowflake） | 常用，ID递增，64位整型 |
| UUID | 唯一但不排序，存储大 |
| 数据库 ID 段 | 通过中心数据库分配 ID 段 |
| Redis/Incr | 快速但依赖 Redis 可用性 |

---

## 7. 简单的 Hash 分表例子（手动实现）

```sql
-- 拆成 4 张表：user_0, user_1, user_2, user_3
-- 路由规则：user_id % 4

-- 插入：
INSERT INTO user_3 (user_id, name) VALUES (1003, 'Tom');

-- 查询：
SELECT * FROM user_3 WHERE user_id = 1003;
```

在业务代码中需要写路由函数，例如：

```js
function getUserTable(userId) {
  const suffix = userId % 4;
  return `user_${suffix}`;
}
```

---


