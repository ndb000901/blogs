# 分布式事务-SAGA

SAGA 是一种专为**长事务（Long Lived Transaction）**设计的解决方案，避免了传统分布式事务模型（如 2PC）带来的**阻塞、性能瓶颈和资源锁定问题**。

---

> SAGA 把一个大事务拆分为多个本地事务，每个本地事务执行成功后，**紧接着下一个**；  
> 如果某一步失败，就按顺序**执行补偿操作（反向事务）**，让系统回滚到一致状态。

---

## 1. SAGA 模型结构

| 阶段       | 内容                                                             |
|------------|------------------------------------------------------------------|
| 正向事务    | 执行一系列业务操作（T1, T2, T3…）                                |
| 补偿事务    | 每个操作都有对应的反操作（C1, C2, C3…），用于失败时回滚整个流程   |
| 编排方式    | 支持两种：**集中式编排** 和 **事件驱动（协作式）**                |

---

## 2.举例：电商下单

### 假设有 3 个服务：
- **订单服务**：创建订单
- **库存服务**：扣减库存
- **账户服务**：扣减账户余额

### 正向流程：
1. 创建订单
2. 扣库存
3. 扣钱

### 补偿流程（假设在第3步失败）：
1. 退款（补偿扣钱）
2. 回滚库存
3. 取消订单

---

## 3. SAGA 时序图（顺序执行 + 失败回滚）

```text
 正向流程：
 T1: 创建订单  ------✔
 T2: 扣减库存 ------✔
 T3: 扣减余额 ------（失败）

 回滚流程：
 C2: 回滚库存 ------✔
 C1: 取消订单 ------✔
```

---

## 4. 实现方式

### 方式一：**编排模式（Orchestration）**

- 有一个 **事务协调者**（Saga Coordinator）控制事务流转
- 比如使用 **状态机/流程引擎**（如 Seata 的 State Machine 模式）

### 方式二：**协作模式（Choreography）**

- 各服务通过**事件发布订阅机制**来触发下一个服务动作或补偿逻辑
- 每个服务负责自己的正向和补偿事务

---

## 5. SAGA 优点

| 优点 | 说明 |
|------|------|
| 非阻塞 | 没有资源锁，不会阻塞数据库 |
| 异步 | 每步可以是异步提交 |
| 高性能 | 不会像 2PC 一样锁资源，适合高并发系统 |
| 易扩展 | 新业务可以插入事务链中 |

---

## 6. SAGA 缺点

| 缺点 | 说明 |
|------|------|
| 实现复杂 | 每个服务都要写正向 + 补偿逻辑 |
| 不保证强一致 | 只能保证最终一致性（如商品已扣但未支付） |
| 补偿不一定等价 | 比如取消订单≠恢复原状态（如优惠券已用） |
| 业务侵入大 | 服务本身需支持补偿操作，业务需考虑重试、幂等、空补偿等问题 |

---

## 7. 幂等性、空补偿、悬挂处理策略

| 问题 | 描述 | 解决方案 |
|------|------|----------|
| 幂等性 | 补偿可能重复执行 | 使用全局事务ID做幂等控制 |
| 空补偿 | 未执行 T，却收到 C | 在 T 中记录事务状态 |
| 悬挂 | C 先于 T 执行 | 判断状态，忽略无效补偿 |

---


