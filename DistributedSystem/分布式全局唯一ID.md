# 分布式全局唯一ID

## 1. 分布式全局唯一 ID

在分布式系统中，单机不能生成唯一 ID，必须满足以下核心属性：

| 需求         | 说明 |
|--------------|------|
| **全局唯一性** | 多个节点生成的 ID 必须不会重复 |
| **高性能**   | 支持高并发生成，比如每秒几十万甚至百万 QPS |
| **有序性**   | 有些业务希望 ID 按时间递增（如数据库主键） |
| **可扩展性** | 支持水平扩容，节点越多不会影响正确性 |
| **高可用性** | 单点失败不能影响全局 ID 生成 |
| **易用性**   | 业务使用简单，尽量本地生成，减少依赖和网络开销 |

---

## 2. 常见的 ID 生成方案

### 2.1 **数据库自增 ID**
- 使用 MySQL 的 `AUTO_INCREMENT`
- 可以加步长 + 起始值 实现分布式递增
```sql
-- 节点1
AUTO_INCREMENT = 1, step = 2
-- 节点2
AUTO_INCREMENT = 2, step = 2
```

优点： 

- 实现简单

缺点：

- 存在数据库瓶颈，扩展性差；有连接和性能问题

---

### 2.2 **UUID（通用唯一标识符）**
- 使用如 `UUID.randomUUID()` 生成
- 128 bit，如：`550e8400-e29b-41d4-a716-446655440000`

优点：

- 保证唯一性、完全本地生成  

缺点：
- **不排序**、**占用空间大**、**不适合做数据库主键**

---

### 2.3 **Snowflake（雪花算法）**

由 Twitter 提出，是目前**最经典的有序、分布式 ID 方案**。

#### Snowflake 64 bit 结构（Twitter 原始）：

```
[1bit符号位][41bit时间戳][10bit机器ID][12bit序列号]
```
- 1 bit：符号位，恒为0
- 41 bit：毫秒时间戳（支持69年）
- 10 bit：节点（数据中心 + 机器号）→ 最多支持 1024 台
- 12 bit：序列号（同毫秒内的计数器）→ 每毫秒支持 4096 个

优点：

- 有序、高性能、本地生成  

缺点：
- 对系统时间依赖强（时间回拨会出问题）
- 机器 ID 需全局唯一（需要部署、管理）

---

### 2.4 **美团 Leaf 框架（Leaf-segment / Leaf-snowflake）**

美团开源的 ID 生成器，支持两种模式：

#### Leaf-segment（号段模式）

- 利用数据库记录 ID 的当前段（如：1000 ~ 2000）
- 每个服务预申请一段，放在内存里生成 ID

高吞吐，**DB压力小**  

依赖数据库；**不适合频繁重启的服务**

#### Leaf-snowflake

- 改进 Snowflake，解决时间回拨等问题，支持持久化机器ID管理

---

### 2.5 **百度 UID-generator**

结构略有不同，支持 workerId 动态注册（Zookeeper/DB），生产级可用。使用 Java 实现。

---

### 2.6 **Twitter Snowflake 改进版（Go/Python/Golang实现）**

开源项目大量模仿实现，比如：
- **Sonyflake（Go）**：适用于不强调时间顺序的场景
- **Duid、KSUID、ULID**：兼顾顺序与唯一性，适合日志、事件系统

---

## 3. 设计分布式 ID 的关键考量

| 要素 | 说明 |
|------|------|
| **时间戳** | 作为主序列，支持排序 |
| **节点 ID** | 机器或进程编号，避免冲突 |
| **序列号** | 毫秒内计数 |
| **时钟回拨处理** | 缓存时钟、等待、抛出异常、配置 NTP |
| **性能** | 每毫秒生成的 ID 数有限，需要本地缓存或批量申请 |

---


