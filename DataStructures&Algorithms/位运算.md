# 位运算

位运算（Bitwise Operation）是一种直接对二进制位进行操作的运算方式，广泛用于底层编程、算法优化、图像处理、加密等领域。
在位运算中，每个操作数都被视为二进制形式，并对其每一位（bit）进行操作。

# 位运算基本运算

## 1.按位与(AND) &

只有两个操作数都为1时，结果为1，否则结果为0

```bash
# x & y
1 & 1 = 1
1 & 0 = 0
0 & 0 = 0

# 举例

0000 0101 = 5
0000 0111 = 7
0000 0101 = 5 & 7
```

## 2.按位或(OR) |

只要有一个操作数为1，结果为1。

```bash
# x | y
1 | 1 = 1
1 | 0 = 1
0 | 0 = 0

# 举例

0000 0101 = 5
0000 0111 = 7
0000 0111 = 5 | 7
```

## 3.按位异或(XOR) ^

两个操作数相同时，结果取0。不同时，结果取1

```bash
# x ^ y
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 0 = 0

# 举例
0000 0101 = 5
0000 0111 = 7
0000 0010 = 5 ^ 7
```

## 4.按位取反(NOT) ~

按位取反，0变1, 1变0
```bash
# 举例

0000 0101 = 5
1111 1010 = ~5

```

## 5.左移(Left Shift) <<

x << n
将x的二进制数据向左移n位，右边补0。相当于x * (2 ^ n)

```bash

0000 0101 = 5
0000 1010 = 5 << 1
0001 0100 = 5 << 2

```

## 6.右移(Right Shift) >>

x >> n
将x的二进制数据向右移n位,左边补0或1。相当于x / (2 ^ n)。
算术右移：保留符号位，正数左边补 0，负数左边补 1。
逻辑右移：不保留符号位，左边总是补 0。

```bash
0000 1001 = 9
0000 0100 = 9 >> 1
0000 0010 = 9 >> 2

```

# 应用

## 1、模拟加法

加法运算本质：对应位的两个数字之和，加上低位的进位(如果有，是1)，如果和大于2(二进制加法)，则向更高位进位1，当前位保留无进位之和。

**无进之和和**

```bash
x ^ b
```

**进位**

```bash
# 只有相同位都为1的
carry = (x & y) << 1
```

**加法运算**

```java
public static int add(int a, int b) {

    // 不断循环，直到进位数据为0
    while (b != 0) {
        // 进位数据
        int carry = (a & b) << 1;
        // 无进位和
        a = a ^ b;
        b = carry;
    }
    return a;
}
```

## 2.判断奇偶性

奇数：最后一位为1
偶数：最后一位为0

```bash
x & 1 == 0 偶数
x & 1 == 1 奇数
```

## 3.交换两个数，而无需使用临时变量

原理：x ^ x = 0; x ^ 0 = x;

```bash
# 交换 x,y
swap(int x, int y) {
    x = x ^ y;
    y = x ^ y; // y = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x; 推导公式中的x,y 为函数最原始传进来的值
    x = x ^ y; // x = (x ^ y) ^ x = (x ^ x) ^ y = 0 ^ y = y;
}
```

## 4.反转比特位

```bash
# 清除最低位的1，常用于统计二进制中有多少个 1
x = x & (x - 1)

# 举例
0000 0111 = 7 = a;

a = a & (a - 1)
  = 0000 0111 &
    0000 0110
  = 0000 0110
  
a = a & (a - 1)
  = 0000 0110 &
    0000 0101
  = 0000 0100

a = a & (a - 1)
  = 0000 0100 &
    0000 0011
  = 0000 0000
  
# a 为0 结束，总共3个位为1

```
**代码**
```java
public static int count1(int a) {
    int count = 0;
    while (a > 0) {
        // 去除最低位1
        a = a & (a - 1);
        count++;
    }
    return count;
}
```

## 5.乘法/除法

```bash
# x * (2 ^ n)
x = x << n;

# x / (2 ^ n)
x = x >> n;
```

## 6.找出两个数不同的位数

```bash
# 找出x, y 不同的位数
result = x ^ y

# 统计result 二进制中1的数量
```

## 7.判断两个数符号位是否相同

```bash
# 符号相同
x ^ y >= 0;

# 符号不同
x ^ y < 0;

```

## 8.判断一个数是否是2的幂

```java
public static boolean isPowerOfTwo(int n) {
    // 只有一位为1
    return n > 0 && (n & (n - 1)) == 0;
}
```

## 9.找到一个数最低位的1

```bash
result = x & -x;

# 举例
0000 0101 = 5
1111 1010 = 反码
1111 1011 = -5(补码表示 = 反码 + 1)
0000 0001 = result = 5 & -5
```

## 10.集合操作

每个为表示1个元素，1表示存在，0表示不存在。
```bash
# 集合交集
result = a & b;

# 集合并集
result = a | b;

# 集合对称差(表示不同时出现在a,b两个集合中的元素)
result = a ^ b;

# 添加元素(添加3号元素)
a = a & (1 << 3)

# 删除元素(删除3号元素)
a = a & ~(1 << 3)
```

## 11、布隆过滤器

布隆过滤器是一种空间效率非常高的数据结构，用于测试一个元素是否属于一个集合。
它使用多个哈希函数将元素映射到位数组的不同位置，并使用位运算对这些位进行操作。

## 12、表示子集

位运算可以高效枚举一个集合的所有子集。
假设有一个集合 {a, b, c}，可以用 3 位二进制数来表示每个子集，如 000 代表空集，001 代表 {c}，010 代表 {b} 等。

## 13、反转位

```bash
# 举例
0000 0101 = 5
1010 0000 = 反转后

```

**方案一**

```java
public static int reverseBits(int n) {
    int result = 0;
    for (int i = 0; i < 32; i++) {
        result |= (n & 1) << (31 - i);
        n >>= 1;
    }
    return result;
}
```

**方案二**
```java
public static int reverseBits2(int n) {
    // 0101 0101 0101 0101 0101 0101 0101 0101 (单个位一组，相临组交换)
    int M1 = 0x55555555;

    // 0011 0011 0011 0011 0011 0011 0011 0011 (两个位一组，相邻的组交换)
    int M2 = 0x33333333;

    // 0000 1111 0000 1111 0000 1111 0000 1111 (四个位一组，相邻的组交换)
    int M4 = 0x0f0f0f0f;

    // 0000 0000 1111 1111 0000 0000 1111 1111 (8个位一组，相邻的组交换)
    int M8 = 0x00ff00ff;
        
    n = ((n >>> 1) & M1) | ((n & M1) << 1);
    n = ((n >>> 2) & M2) | ((n & M2) << 2);
    n = ((n >>> 4) & M4) | ((n & M4) << 4);
    n = ((n >>> 8) & M8) | ((n & M8) << 8);

    // 16位一组，交换
    return n >>> 16 | n << 16;

}
```

## 14.找出只出现一次的数，其他数出现两次

原理：x ^ x = 0; x ^ 0 = x;

```java
public static int singleNumber(int[] nums) {
    int result = 0;
    for (int num: nums) {
        result ^= num;
    }
    return result;
}
```

## 15.找出只出现一次的数，其他数出现n次(奇数)

按位计数，每位的计数结果 % n, 结果为1的是出现一次的数
```java
public int singleNumber(int[] nums) {
    int[] result = new int[32];
    for (int num : nums) {
        for (int i = 0; i < 32; i++) {
            result[i] += ((num >> i) & 1);
        }
    }

    int ret = 0;
    for (int i = 0; i < 32; i++) {
        if (result[i] % 3 == 1) {
            ret |= (1 << i);
        }
    }
    return ret;

}
```