# 栈溢出

**栈溢出**（Stack Overflow）是指程序在执行过程中向栈内存写入数据时，超过了栈的最大容量或栈帧的边界，从而破坏了栈上的数据结构，可能引发程序崩溃、逻辑错误，甚至被攻击者利用执行任意代码。

这是最经典、最常见的内存安全漏洞之一，特别是在早期的C/C++程序中，因边界检查不当而频繁出现。

---

## 1. 栈（Stack）

栈是程序运行时用于存储函数调用信息、局部变量、返回地址等数据的一块连续内存区域，遵循 **“先进后出”**（LIFO）的原则。

每调用一个函数，系统会将函数的返回地址、参数、局部变量等信息压入栈中，形成一个**栈帧**（Stack Frame）；函数返回时，该栈帧会被弹出。

---

## 2. 栈溢出产生的原因

**栈溢出发生在：**  
当写入数据超过了为栈分配的空间时，数据会覆盖掉原本不该被改动的区域，比如：

- 返回地址
- 上一个函数的栈帧
- 控制结构（如函数指针）

### 常见原因：

1. **局部缓冲区写入过大**
   ```c
   void vulnerable(char *input) {
       char buffer[100];
       strcpy(buffer, input); // 没有检查长度
   }
   ```
   如果 `input` 超过 100 字节，就会覆盖 `buffer` 之后的内存区域，造成栈溢出。

2. **递归调用过深**
   ```c
   void recursive() {
       recursive();
   }
   ```
   每次调用函数都会压栈，调用过多会导致栈耗尽。

---

## 3. 栈溢出利用

攻击者会利用溢出覆盖掉栈上的 **返回地址**，使得程序函数在返回时跳转到攻击者控制的地址（比如注入的 shellcode）。

### 示例代码：

```c
void vulnerable() {
    char buffer[64];
    gets(buffer);  // 危险函数，没有长度限制
}

int main() {
    vulnerable();
    return 0;
}
```

### 攻击流程：
1. 向 `buffer` 中输入超过 64 字节的数据。
2. 数据会覆盖返回地址。
3. 控制程序流，执行攻击者指定的指令。

---

## 4. 防御机制

现代操作系统和编译器提供了多种机制来防止栈溢出被利用：

### 4.1 **Stack Canary（栈金丝雀）**
在返回地址和局部变量之间放一个特殊值，在函数返回前检查是否被篡改。

编译启用方式：
```bash

gcc -fstack-protector-all test.c -o test
```

### 4.2 **ASLR（地址空间随机化）**
让栈、堆、库、程序代码等每次运行时地址都不同，增加攻击者构造 payload 的难度。

### 4.3 **DEP / NX（不可执行栈）**
禁止执行栈上的代码，即使你能写入 shellcode，也不能执行。

### 4.4 **SSP（Stack Smashing Protector）**
GCC 的防溢出机制，通过插入检查代码检测溢出。

---

