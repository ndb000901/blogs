# 排序算法


## 1.冒泡排序(Bubble Sort)

- [冒泡排序](./冒泡排序.md)

## 2.选择排序(Selection Sort)

- [选择排序](./选择排序.md)

## 3.插入排序(Insertion Sort)

- [插入排序](./插入排序.md)

## 4.归并排序(Merge Sort)

- [归并排序](./归并排序.md)

## 5.快速排序(Quick Sort)

- [快速排序](./快速排序.md)

## 6.堆排序(Heap Sort)

- [堆排序](./堆排序.md)

## 7.计数排序(Counting Sort)

- [计数排序](./计数排序.md)

## 8.基数排序(Radix Sort)

- [基数排序](./基数排序.md)

## 9.桶排序(Bucket Sort)

- [桶排序](./桶排序.md)


常见的排序算法有多种，它们在不同的场景下具有不同的优势和劣势。以下是一些最常见的排序算法：

### 1. **冒泡排序 (Bubble Sort)** 
   - **原理**：通过重复遍历列表，比较相邻元素并交换它们以确保较大或较小的元素逐步移动到正确位置。
   - **时间复杂度**：最坏情况下为 O(n²)，最好的情况是 O(n)。
   - **稳定性**：稳定。
   - **优点**：实现简单，适合小规模数据集。
   - **缺点**：对于大型数据集效率低。

### 2. **选择排序 (Selection Sort)**
   - **原理**：在未排序的部分中找到最小或最大的元素，将其与未排序部分的第一个元素交换，重复此过程。
   - **时间复杂度**：O(n²)。
   - **稳定性**：不稳定。
   - **优点**：空间复杂度低 (O(1))，适合内存受限场景。
   - **缺点**：性能较差，尤其是对大量数据。

### 3. **插入排序 (Insertion Sort)**
   - **原理**：通过构建一个逐步排序的列表，插入每个新元素到它合适的位置。
   - **时间复杂度**：最坏情况 O(n²)，最好的情况是 O(n)。
   - **稳定性**：稳定。
   - **优点**：适用于数据规模较小或部分有序的数据，性能较好。
   - **缺点**：对于大型随机数据集，性能较差。

### 4. **归并排序 (Merge Sort)**
   - **原理**：递归地将数组分成两半，分别排序后再合并已排序的部分。
   - **时间复杂度**：O(n log n)。
   - **稳定性**：稳定。
   - **优点**：在大规模数据集上表现优异，尤其是对于链表和外部排序。
   - **缺点**：需要 O(n) 的额外空间。

### 5. **快速排序 (Quick Sort)**
   - **原理**：选择一个基准元素，将数组分成两部分，一部分比基准元素小，另一部分比基准元素大，递归地对这两部分排序。
   - **时间复杂度**：最坏情况 O(n²)，但平均为 O(n log n)。
   - **稳定性**：不稳定。
   - **优点**：平均性能非常好，且空间利用率高。
   - **缺点**：最坏情况下可能会退化为 O(n²)。

### 6. **堆排序 (Heap Sort)**
   - **原理**：将数组视为二叉堆，首先构建最大堆，然后重复提取堆顶元素并进行堆调整。
   - **时间复杂度**：O(n log n)。
   - **稳定性**：不稳定。
   - **优点**：空间复杂度为 O(1)，不需要额外的存储空间。
   - **缺点**：对于链表或类似数据结构效率不高。

### 7. **计数排序 (Counting Sort)**
   - **原理**：通过计算每个元素出现的次数，直接定位每个元素在排序后数组中的位置。
   - **时间复杂度**：O(n + k)，其中 k 是元素的范围。
   - **稳定性**：稳定。
   - **优点**：对范围已知且较小的数据非常有效。
   - **缺点**：需要额外的空间，且不适用于元素范围过大的数据。

### 8. **基数排序 (Radix Sort)**
   - **原理**：按位（从最低位到最高位或从最高位到最低位）对每个元素进行排序，通常使用计数排序作为子程序。
   - **时间复杂度**：O(n * k)，其中 k 是位数。
   - **稳定性**：稳定。
   - **优点**：适用于整数和字符串的排序，且效率较高。
   - **缺点**：需要额外的空间。

### 9. **桶排序 (Bucket Sort)**
   - **原理**：将数据分到固定数量的桶中，每个桶分别排序，最后合并所有桶中的数据。
   - **时间复杂度**：O(n + k)，其中 k 是桶的数量。
   - **稳定性**：稳定。
   - **优点**：适用于均匀分布的数据，性能优秀。
   - **缺点**：当数据分布不均时，性能可能不佳。



