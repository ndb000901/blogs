# 系统调用

## 1.环境

```shell
# lsb_release -a                                                                                                                               04:28:41

No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 22.04.4 LTS
Release:	22.04
Codename:	jammy

# uname -a                                                                                                                                  04:28:45
Linux dev 5.15.0-124-generic #134-Ubuntu SMP Fri Sep 27 20:20:17 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux

```

## 2.介绍

系统调用（System Call）是应用程序与操作系统内核之间通信的接口。通过系统调用，应用程序可以请求操作系统执行底层的硬件管理和资源分配工作，如文件操作、内存管理、进程控制等。系统调用是用户态到内核态的重要桥梁，确保了程序可以在内核受保护的模式下安全地访问硬件和关键资源。

以下是 Linux 系统中一些重要的系统调用：

### 1. **文件操作系统调用**
   - **open()**：打开文件或设备，返回一个文件描述符。
   - **read()**：从文件描述符中读取数据。
   - **write()**：将数据写入文件描述符。
   - **close()**：关闭文件描述符，释放资源。
   - **lseek()**：调整文件描述符的读写位置。
   - **stat()** / **fstat()** / **lstat()**：获取文件的元数据（如大小、权限、修改时间等）。
   - **mmap()**：将文件或设备映射到内存区域，便于快速访问。

### 2. **进程管理系统调用**
   - **fork()**：创建子进程，是 UNIX 系统多任务的核心机制，父子进程拥有相同的代码和数据空间。
   - **execve()**：在进程中执行新的程序，用于执行不同的二进制文件。
   - **wait()** / **waitpid()**：等待子进程结束，回收子进程资源。
   - **exit()**：退出进程，通知父进程并释放相关资源。
   - **kill()**：向进程发送信号，如终止或暂停进程。
   - **getpid()** / **getppid()**：获取当前进程 ID 和父进程 ID。
   - **sched_yield()**：放弃当前进程的 CPU 使用权，使调度器调度其他进程。

### 3. **内存管理系统调用**
   - **brk()** / **sbrk()**：调整数据段（堆）的大小，通常用于实现 `malloc`。
   - **mmap()** / **munmap()**：映射或取消映射内存页，常用于文件和设备映射，或分配大块内存。
   - **mprotect()**：修改内存区域的访问权限，例如设置为只读或可执行。
   - **mlock()** / **munlock()**：锁定或解锁内存，防止其被交换到磁盘上。

### 4. **线程与同步系统调用**
   - **clone()**：用于创建线程，指定新线程与调用者共享的资源（如文件描述符和内存）。
   - **pthread_create()**：创建新线程（依赖于 `clone()`）。
   - **futex()**：快速用户空间互斥锁，为线程同步提供高效支持。
   - **semget()** / **semop()** / **semctl()**：用于管理信号量，用于进程间同步。

### 5. **信号处理系统调用**
   - **signal()** / **sigaction()**：设置信号处理函数，指定在特定信号到达时执行的处理程序。
   - **raise()**：向当前进程发送信号。
   - **sigprocmask()**：检查或更改进程的信号屏蔽字。
   - **sigsuspend()**：等待信号并原子地恢复信号掩码。

### 6. **网络系统调用**
   - **socket()**：创建一个新的网络套接字。
   - **bind()**：绑定套接字到一个地址（IP + 端口）。
   - **listen()**：将套接字设为监听模式，准备接受连接。
   - **accept()**：接受客户端的连接请求，返回新的套接字。
   - **connect()**：客户端发起连接请求。
   - **send()** / **recv()**：发送或接收数据。
   - **sendto()** / **recvfrom()**：在无连接套接字上发送或接收数据。
   - **shutdown()**：关闭网络连接的一部分或全部。
  
### 7. **时间管理系统调用**
   - **time()**：获取当前时间。
   - **gettimeofday()**：获取更高精度的当前时间。
   - **clock_gettime()**：获取指定时钟的时间，如 `CLOCK_REALTIME` 或 `CLOCK_MONOTONIC`。
   - **nanosleep()**：使进程睡眠指定的纳秒时间。
   - **alarm()**：在指定时间后发送 `SIGALRM` 信号。

### 8. **权限与用户管理系统调用**
   - **getuid()** / **getgid()**：获取进程的用户 ID 和组 ID。
   - **setuid()** / **setgid()**：设置进程的用户 ID 和组 ID。
   - **chmod()** / **fchmod()**：修改文件权限。
   - **chown()** / **fchown()**：修改文件的所有者和组。
   - **umask()**：设置创建文件的默认权限掩码。

### 9. **设备管理系统调用**
   - **ioctl()**：执行设备控制操作，可以对文件描述符执行特定控制操作。
   - **fcntl()**：控制文件描述符的属性，例如设置文件锁、非阻塞模式等。
   - **open()** / **close()**：用于文件描述符的打开和关闭，但对于设备文件也可以操作设备。

### 10. **系统信息系统调用**
   - **uname()**：获取系统信息，如内核版本、主机名等。
   - **sysinfo()**：获取系统的整体信息（内存、负载等）。
   - **getrusage()**：获取当前进程或子进程的资源使用信息。
   - **getloadavg()**：获取系统负载平均值。

### 系统调用的执行过程
1. **用户态**：程序在用户态中发起系统调用，例如调用 `read()` 函数。
2. **陷入内核态**：系统调用会触发陷阱指令，将 CPU 切换到内核态，开始执行操作系统内核的代码。
3. **系统调用处理**：内核根据调用的系统调用号找到对应的内核函数（如 `sys_read`），执行相应的操作。
4. **返回用户态**：系统调用完成后，将结果返回给用户态进程，进程恢复执行。

### 系统调用与库函数的关系
- 用户态程序通常不会直接调用系统调用接口，而是通过 C 标准库或其他库中的封装函数来间接调用。例如 `printf()` 会调用 `write()` 系统调用来实现输出。
- 系统调用是底层内核接口，而库函数往往会对系统调用进行进一步的封装和优化，使开发更加方便。