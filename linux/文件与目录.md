# 文件与目录

## 1.文件类型

在 Linux 中，文件类型可以通过 `ls -l` 命令查看，文件类型信息会显示在每个文件或目录的权限字符串的最前面。Linux 中常见的文件类型包括以下几种：

1. **普通文件（Regular file）**  
   - 符号：`-`
   - 描述：普通文件包含数据，可以是文本、图像、可执行程序等。
   - 示例：`-rw-r--r--`

2. **目录文件（Directory）**  
   - 符号：`d`
   - 描述：目录文件包含其他文件和目录，类似文件夹。
   - 示例：`drwxr-xr-x`

3. **符号链接（Symbolic link）**  
   - 符号：`l`
   - 描述：符号链接是指向另一个文件或目录的快捷方式。
   - 示例：`lrwxrwxrwx`

4. **字符设备文件（Character device）**  
   - 符号：`c`
   - 描述：字符设备文件提供与设备进行字符流交互的接口，例如终端设备。
   - 示例：`crw-rw-rw-`

5. **块设备文件（Block device）**  
   - 符号：`b`
   - 描述：块设备文件提供与设备进行块数据交互的接口，例如硬盘驱动器。
   - 示例：`brw-rw----`

6. **管道文件（Pipe，或称命名管道 FIFO）**  
   - 符号：`p`
   - 描述：用于进程间通信，允许数据流单向传递。
   - 示例：`prw-r--r--`

7. **套接字文件（Socket）**  
   - 符号：`s`
   - 描述：套接字文件用于网络通信或进程间通信。
   - 示例：`srwxr-xr-x`

在输出中，最左侧的第一个字符表示文件类型。

## 2.stat,fstat,fstatat,lstat

在 Linux 的 C 语言编程中，`stat` 是一个系统调用函数，用于获取文件的详细信息。
`stat` 函数可以获取文件的类型、大小、权限、时间戳等信息，这在文件操作和系统编程中非常有用。

### 函数声明

`stat` 和其相关函数在 `<sys/stat.h>` 头文件中声明：

```c
#include <sys/stat.h>
int stat(const char *pathname, struct stat *buf);
int lstat(const char *pathname, struct stat *buf);
int fstat(int fd, struct stat *buf);
int fstatat(int dirfd, const char *pathname, struct stat *statbuf, int flags);
```

- `stat`：获取文件的状态信息。
- `lstat`：获取符号链接本身的状态信息（而不是它指向的文件）。
- `fstat`：获取文件描述符 `fd` 指向的文件的状态信息。
- `fstatat`: 基于当前目录(drifd指向的目录)，获取文件统计信息。flag控制是否跟随符号链接文件。

### 参数

- `pathname`：要查询的文件路径。
- `fd`：文件描述符，用于 `fstat`。
- `buf`：指向 `stat` 结构体的指针，用于存储文件的状态信息。

### 返回值

- 成功时返回 `0`，并将文件状态信息存储在 `buf` 指向的 `stat` 结构体中。
- 失败时返回 `-1`，并设置 `errno` 以指示错误原因。

### `stat` 结构体

`stat` 结构体（定义在 `<sys/stat.h>` 中）包含文件的详细信息：

```c
struct stat {
    dev_t     st_dev;     /* 设备 ID */
    ino_t     st_ino;     /* inode 编号 */
    mode_t    st_mode;    /* 文件类型和权限 */
    nlink_t   st_nlink;   /* 硬链接数 */
    uid_t     st_uid;     /* 文件所有者的用户 ID */
    gid_t     st_gid;     /* 文件所有者的组 ID */
    dev_t     st_rdev;    /* 特殊设备 ID（若文件为特殊设备） */
    off_t     st_size;    /* 文件大小（字节） */
    blksize_t st_blksize; /* IO 块大小 */
    blkcnt_t  st_blocks;  /* 占用的块数 */
    time_t    st_atime;   /* 上次访问时间 */
    time_t    st_mtime;   /* 上次修改时间 */
    time_t    st_ctime;   /* 上次状态更改时间 */
};
```

### 注意事项

- **权限检查**：在使用 `stat` 系统调用之前，确保应用程序有权限访问该文件。
- **符号链接**：使用 `lstat` 可以避免符号链接被解引用而指向目标文件。

### 示例代码

```c
#include<sys/stat.h>
#include<stdio.h>

int main(int argc, char const *argv[])
{
    struct stat buf;
    int ret = stat("./stat-demo.c", &buf);

    printf("uid: %d\n", buf.st_uid);
    printf("gid: %d\n", buf.st_gid);
    printf("device number: %d\n", buf.st_dev);
    printf("i-node number: %d\n", buf.st_ino);
    printf("mode: %d\n", buf.st_mode);
    printf("number of links: %d\n", buf.st_nlink);
    printf("file size: %d\n", buf.st_size);
    printf("last access time: %d\n", buf.st_atime);
    printf("last modified time: %d\n", buf.st_mtime);
    printf("creation time: %d\n", buf.st_ctime);

    // 判断文件类型
    // 普通文件
    if (S_ISREG(buf.st_mode))
    {
        printf("regular file\n");
    }
    // 目录文件
    else if (S_ISDIR(buf.st_mode))
    {
        printf("directory file\n");
    }
    // 字符设备文件
    else if (S_ISCHR(buf.st_mode))
    {
        printf("character device file\n");
    }
    // 块设备文件
    else if (S_ISBLK(buf.st_mode))
    {
        printf("block device file\n");
    }
    // FIFO文件或管道
    else if (S_ISFIFO(buf.st_mode))
    {
        printf("fifo file\n");
    }
    // 符号链接文件
    else if (S_ISLNK(buf.st_mode))
    {
        printf("symbolic link file\n");
    }
    // socket文件
    else if (S_ISSOCK(buf.st_mode))
    {
        printf("socket file\n");
    }
    
    return 0;
}

```

### 输出

```shell
uid: 1000
gid: 1000
device number: 64768
i-node number: 13780838
mode: 33204
number of links: 1
file size: 1395
last access time: 1730476589
last modified time: 1730476589
creation time: 1730476589
regular file
```

## 3.umask

`umask`（用户文件创建掩码）是在 Unix 和 Linux 系统上用来设置新创建文件和目录的默认权限的命令。`umask` 决定了文件或目录的权限被移除的部分，表示哪些权限将不赋予新创建的文件或目录。

### 工作原理
- 系统默认的权限通常是：
  - 文件：`666`（即允许读写）
  - 目录：`777`（即允许读、写和执行）

- `umask` 值会从这些默认权限中移除指定的权限。例如，umask 设置为 `022` 时，系统会从默认权限中减去 `022`，这样新创建的文件权限将是 `644`（即 `666 - 022`），目录权限将是 `755`（即 `777 - 022`）。

## 3.设置用户id 和设置组id

在 Linux 中，设置用户 ID（UID）和组 ID（GID）可以通过文件的权限位来实现。这主要涉及 `setuid` 和 `setgid` 位，它们用于指定文件在执行时临时更改进程的有效 UID 或 GID，从而提升权限或访问权限更高的资源。以下是详细说明：

### `setuid`（设置用户 ID）

设置 `setuid` 位可以使文件在执行时拥有文件所有者的用户 ID，而不仅仅是执行该文件的用户的 ID。一般用于具有高权限的程序（如 `passwd`），使普通用户可以临时获得较高权限来执行特定任务。

- **设置 `setuid`**：
  ```bash
  chmod u+s filename
  ```
  - `u+s`：将 `setuid` 位设置给文件所有者。

- **识别 `setuid` 文件**：
  执行 `ls -l` 查看文件权限时，可以看到权限位中用户权限部分的 `s`（如 `-rwsr-xr-x`），表示 `setuid` 位已设置。

- **注意**：
  `setuid` 仅在文件是可执行文件时生效。

### `setgid`（设置组 ID）

设置 `setgid` 位可以使文件在执行时拥有文件所属组的组 ID。这在组共享文件夹或可执行文件时很有用，可以确保所有文件在同一组内共享权限。

- **设置 `setgid`**：
  ```bash
  chmod g+s filename
  ```
  - `g+s`：将 `setgid` 位设置给文件所属组。

- **识别 `setgid` 文件或目录**：
  在 `ls -l` 输出中可以看到权限位中组权限部分的 `s`（如 `-rwxr-sr-x`），表示 `setgid` 位已设置。

- **目录上的 `setgid`**：
  对于目录，`setgid` 位确保该目录内创建的文件或目录继承其所属组。

### 取消 `setuid` 和 `setgid`

- **取消 `setuid`**：
  ```bash
  chmod u-s filename
  ```
- **取消 `setgid`**：
  ```bash
  chmod g-s filename
  ```

### `setuid` 和 `setgid` 示例

#### 示例 1：给文件设置 `setuid`

```bash
# 创建一个可执行文件
touch testfile
chmod +x testfile

# 设置 setuid 位
chmod u+s testfile

# 查看权限
ls -l testfile
# 输出：-rwsr-xr-x  1 user group 0 Oct 31 10:00 testfile
```

#### 示例 2：给目录设置 `setgid`

```bash
# 创建一个目录
mkdir shared_dir

# 设置 setgid 位
chmod g+s shared_dir

# 查看权限
ls -ld shared_dir
# 输出：drwxr-sr-x  2 user group 4096 Oct 31 10:00 shared_dir
```

在 `shared_dir` 目录内创建的文件和目录将自动继承 `shared_dir` 的组 ID。

#### 示例3: passwd

```shell
# ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 59976 Feb  6  2024 /usr/bin/passwd

# ls -l /etc/passwd
-rw-r--r-- 1 root root 1833 Apr 21  2024 /etc/passwd

# 当用户执行passwd 命令时，启动的passwd进程的有效用户ID 被设置为passwd程序的文件拥有者

# sudo su
# chmod u-x /usr/bin/passwd
# ls -l /usr/bin/passwd
# 没有执行权限的标志为大写S
-rwSr-xr-x 1 root root 59976 Feb  6  2024 /usr/bin/passwd
```


## 4.文件访问权限

在Linux中，文件的访问权限控制着哪些用户或用户组可以读取、写入或执行文件。权限通常通过 **rwx** 三种类型表示：

1. **r** (read)：读取权限。用户可以查看文件内容。
2. **w** (write)：写入权限。用户可以修改文件内容。
3. **x** (execute)：执行权限。用户可以执行文件（适用于脚本或可执行文件）。

文件权限分为三类主体：

- **所有者 (Owner)**：文件的创建者，通常拥有最高权限。
- **组 (Group)**：用户组内的成员可以共享一些文件权限。
- **其他人 (Others)**：不属于文件所有者或用户组的用户。

### 权限表示

用 `ls -l` 命令查看文件权限。例如：

```
-rwxr-xr--
```

解释如下：

- 第一个字符 `-` 表示这是一个普通文件（若为 `d` 则表示目录）。
- 后面三个字符 `rwx` 表示所有者的权限（读、写、执行）。
- 接下来的 `r-x` 表示用户组的权限（读、执行）。
- 最后 `r--` 表示其他用户的权限（只读）。

### 改变文件权限

使用 `chmod` 命令更改权限：

- 八进制表示法（推荐）：
  - `chmod 755 filename` 设置为 `rwxr-xr-x`。
  - `chmod 644 filename` 设置为 `rw-r--r--`。

- 符号表示法：
  - `chmod u+x filename`：为所有者添加执行权限。
  - `chmod g-w filename`：移除组写权限。
  - `chmod o+r filename`：为其他用户添加读权限。

### 访问权限位

```c
#include<sys/stat.h>

// 用户相关权限
S_IRUSR  // 用户读
S_IWUSR  // 用户写
S_IXUSR  // 用户执行

// 组相关权限
S_IRGRP  // 组读
S_IWGRP  // 组写
S_IXGRP  // 组执行

// 其他用户权限
S_IROTH  // 其他读
S_IWOTH  // 其他写
S_IXOTH  // 其他执行

```

### 代码示例

```c
#include<sys/stat.h>
#include<stdio.h>

int main(int argc, char const *argv[])
{
    struct stat buf;
    stat("./stat-demo.c", &buf);
    printf(
        "S_IRUSR: %d, S_IWUSR: %d, S_IXUSR: %d\n",
        buf.st_mode & S_IRUSR ? 1 : 0,
        buf.st_mode & S_IWUSR ? 1 : 0,
        buf.st_mode & S_IXUSR ? 1 : 0
    );
    printf(
        "S_IRGRP: %d, S_IWGRP: %d, S_IXGRP: %d\n",
        buf.st_mode & S_IRGRP ? 1 : 0,
        buf.st_mode & S_IWGRP ? 1 : 0,
        buf.st_mode & S_IXGRP ? 1 : 0
    );
    printf(
        "S_IROTH: %d, S_IWOTH: %d, S_IXOTH: %d\n",
        buf.st_mode & S_IROTH ? 1 : 0,
        buf.st_mode & S_IWOTH ? 1 : 0,
        buf.st_mode & S_IXOTH ? 1 : 0
    );

    return 0;
}

```

## 5.access, faccessat

在Linux系统中，`access` 和 `faccessat` 是两个系统调用，用于检查调用进程是否有权限访问文件。这两个函数的用途类似，但`faccessat`提供了更强的灵活性，特别是在处理相对路径时。

### `access` 系统调用

`access` 用于检查当前进程是否对指定路径的文件具有指定的访问权限。它不依赖文件的拥有者权限，而是检查调用进程是否能够按照所要求的方式访问文件。

#### 函数原型
```c
#include <unistd.h>

int access(const char *pathname, int mode);
```

- **参数**：
  - `pathname`：要检查的文件路径。
  - `mode`：要检查的权限类型，可以是以下标志的组合：
    - `R_OK`：检查读权限。
    - `W_OK`：检查写权限。
    - `X_OK`：检查执行权限。
    - `F_OK`：检查文件是否存在。

- **返回值**：
  - 返回 `0` 表示进程具有指定的权限。
  - 返回 `-1` 表示没有权限，并设置 `errno`。

#### 使用示例
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    if (access(filename, R_OK) == 0) {
        printf("File is readable\n");
    } else {
        perror("File is not readable");
    }

    return 0;
}
```

### `faccessat` 系统调用

`faccessat` 是 `access` 的扩展版本，支持相对路径并允许指定基目录文件描述符，通常用于更复杂的文件访问场景，比如沙盒环境或基于某个目录的路径访问。

#### 函数原型
```c
#include <unistd.h>

int faccessat(int dirfd, const char *pathname, int mode, int flags);
```

- **参数**：
  - `dirfd`：文件描述符，可以是一个打开的目录描述符，也可以是以下常量：
    - `AT_FDCWD`：表示使用当前工作目录。
  - `pathname`：要检查的文件路径。
  - `mode`：权限标志，和 `access` 相同。
  - `flags`：附加标志，常用的有：
    - `AT_EACCESS`：检查访问权限，基于进程的真实用户ID和组ID，而不是有效ID。

- **返回值**：
  - 返回 `0` 表示具有指定权限。
  - 返回 `-1` 表示没有权限，并设置 `errno`。

#### 使用示例
```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    // 使用当前目录作为基目录
    if (faccessat(AT_FDCWD, filename, R_OK, 0) == 0) {
        printf("File is readable\n");
    } else {
        perror("File is not readable");
    }

    return 0;
}
```

### `access` vs `faccessat`

- **相对路径支持**：`access` 只能处理绝对路径，而 `faccessat` 支持相对路径和基于文件描述符的路径。
- **灵活性**：`faccessat` 更加灵活，适合处理沙盒环境中的文件访问权限检查。
- **推荐使用**：如果应用需要支持相对路径和目录文件描述符，推荐使用 `faccessat`；否则，可以使用 `access`。

### 注意事项

- **安全性**：不建议在程序中依赖 `access` 和 `faccessat` 来检查权限，然后再进行访问操作，因为这会导致 TOCTTOU (Time-of-check-to-time-of-use) 问题。

## 6.chmod,fchmod,fchmodat

在Linux系统中，`chmod`、`fchmod` 和 `fchmodat` 是用于修改文件权限的系统调用。这些函数的主要区别在于它们的调用方式和应用场景：

- **`chmod`**：用于按路径设置文件权限。
- **`fchmod`**：通过文件描述符来设置文件权限。
- **`fchmodat`**：在指定目录中相对路径设置文件权限，支持更灵活的目录描述符和相对路径。

### 1. `chmod` 系统调用

`chmod` 函数按文件路径修改文件的权限。

#### 函数原型
```c
#include <sys/stat.h>

int chmod(const char *pathname, mode_t mode);
```

- **参数**：
  - `pathname`：文件路径。
  - `mode`：权限模式，例如 `0644` 或使用权限宏如 `S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH`。
  
- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <sys/stat.h>
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    // 设置文件权限为 0644
    if (chmod(filename, 0644) == 0) {
        printf("Permissions changed successfully\n");
    } else {
        perror("chmod");
    }

    return 0;
}
```

### 2. `fchmod` 系统调用

`fchmod` 函数通过文件描述符修改文件的权限。它通常在文件已经打开的情况下使用。

#### 函数原型
```c
#include <sys/stat.h>

int fchmod(int fd, mode_t mode);
```

- **参数**：
  - `fd`：文件描述符。
  - `mode`：权限模式，与 `chmod` 相同。
  
- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    int fd = open("test.txt", O_RDWR);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    // 修改文件权限为 0644
    if (fchmod(fd, 0644) == 0) {
        printf("Permissions changed successfully\n");
    } else {
        perror("fchmod");
    }

    close(fd);
    return 0;
}
```

### 3. `fchmodat` 系统调用

`fchmodat` 是 `chmod` 的更灵活版本，支持相对路径、文件描述符作为基准目录等。它通常用于操作基于某个目录的文件权限，适用于沙盒环境或需要在特定目录下操作的情况。

#### 函数原型
```c
#include <sys/stat.h>
#include <fcntl.h>

int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);
```

- **参数**：
  - `dirfd`：目录文件描述符，可以使用 `AT_FDCWD` 表示当前工作目录。
  - `pathname`：文件路径。
  - `mode`：权限模式。
  - `flags`：附加选项，常用值为 `0`。如果设置为 `AT_SYMLINK_NOFOLLOW`，则不跟随符号链接。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    // 使用当前工作目录作为基目录，设置权限为 0644
    if (fchmodat(AT_FDCWD, filename, 0644, 0) == 0) {
        printf("Permissions changed successfully\n");
    } else {
        perror("fchmodat");
    }

    return 0;
}
```

### `chmod` vs `fchmod` vs `fchmodat`

- **`chmod`**：直接按路径修改权限，适合一般文件修改。
- **`fchmod`**：按文件描述符修改权限，适用于文件已经打开的情况。
- **`fchmodat`**：支持基准目录描述符及相对路径，适合更灵活的文件路径管理，尤其是沙盒环境。

### mode常量

```c
#include<sys/stat.h>

// 
S_ISUID  // 执行时设置用户ID
S_ISGID  // 执行时设置组ID
S_ISVTX  // 保存正文(粘着位)

// 用户相关权限 S_IRWXU
S_IRUSR  // 用户读
S_IWUSR  // 用户写
S_IXUSR  // 用户执行

// 组相关权限 S_IRWXG
S_IRGRP  // 组读
S_IWGRP  // 组写
S_IXGRP  // 组执行

// 其他用户权限 S_IRWXO
S_IROTH  // 其他读
S_IWOTH  // 其他写
S_IXOTH  // 其他执行
```
## 7.chown,fchown,fchownat,lchown

在Linux中，`chown`、`fchown`、`fchownat` 和 `lchown` 是用于修改文件或目录的所有者和所属组的系统调用。这些函数在实现和使用上略有不同，以满足不同的操作需求。

### 1. `chown` 系统调用

`chown` 用于通过文件路径更改文件的用户和组所有者。

#### 函数原型
```c
#include <unistd.h>

int chown(const char *pathname, uid_t owner, gid_t group);
```

- **参数**：
  - `pathname`：文件路径。
  - `owner`：新文件所有者的用户ID。使用 `-1` 表示不更改用户。
  - `group`：新文件所属组的组ID。使用 `-1` 表示不更改组。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    // 将文件所有者设置为用户ID 1000，组设置为组ID 1000
    if (chown(filename, 1000, 1000) == 0) {
        printf("Ownership changed successfully\n");
    } else {
        perror("chown");
    }

    return 0;
}
```

### 2. `fchown` 系统调用

`fchown` 通过文件描述符来更改文件的用户和组所有者。它适用于文件已被打开的情况。

#### 函数原型
```c
#include <unistd.h>

int fchown(int fd, uid_t owner, gid_t group);
```

- **参数**：
  - `fd`：文件描述符。
  - `owner` 和 `group`：含义与 `chown` 相同。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    int fd = open("test.txt", O_RDWR);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    // 修改文件所有者和组为 1000
    if (fchown(fd, 1000, 1000) == 0) {
        printf("Ownership changed successfully\n");
    } else {
        perror("fchown");
    }

    close(fd);
    return 0;
}
```

### 3. `fchownat` 系统调用

`fchownat` 是更灵活的版本，允许指定基目录文件描述符和相对路径，并有额外的选项控制符号链接的处理方式。

#### 函数原型
```c
#include <unistd.h>
#include <fcntl.h>

int fchownat(int dirfd, const char *pathname, uid_t owner, gid_t group, int flags);
```

- **参数**：
  - `dirfd`：基准目录的文件描述符，使用 `AT_FDCWD` 表示当前工作目录。
  - `pathname`：文件路径。
  - `owner` 和 `group`：含义同上。
  - `flags`：常用选项：
    - `0`：默认。
    - `AT_SYMLINK_NOFOLLOW`：不跟随符号链接。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    // 使用当前目录作为基准目录，并设置所有者和组为 1000
    if (fchownat(AT_FDCWD, filename, 1000, 1000, 0) == 0) {
        printf("Ownership changed successfully\n");
    } else {
        perror("fchownat");
    }

    return 0;
}
```

### 4. `lchown` 系统调用

`lchown` 类似于 `chown`，但它不会跟随符号链接，而是直接更改符号链接本身的所有者和组。这个调用适用于不希望影响符号链接指向文件的情况。

#### 函数原型
```c
#include <unistd.h>

int lchown(const char *pathname, uid_t owner, gid_t group);
```

- **参数**：
  - `pathname`：文件路径。
  - `owner` 和 `group`：含义同上。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *filename = "symlink";

    // 设置符号链接本身的所有者和组为 1000
    if (lchown(filename, 1000, 1000) == 0) {
        printf("Symbolic link ownership changed successfully\n");
    } else {
        perror("lchown");
    }

    return 0;
}
```

### 总结

| 函数       | 功能                               | 特点                                    |
|------------|------------------------------------|-----------------------------------------|
| `chown`    | 更改文件的用户和组所有者            | 基于文件路径                           |
| `fchown`   | 更改文件的用户和组所有者            | 基于文件描述符                         |
| `fchownat` | 更改文件的用户和组所有者            | 支持目录文件描述符和符号链接处理       |
| `lchown`   | 更改符号链接本身的用户和组所有者     | 不跟随符号链接，直接作用于符号链接     |


## 8.文件截断

在Linux中，可以使用`truncate`和`ftruncate`系统调用来对文件进行截断操作。文件截断的作用是调整文件的大小：截断后的文件如果大于原大小，文件会用空字节（通常为`\0`）填充；如果小于原大小，文件会被裁剪到指定大小。

### 1. `truncate` 系统调用

`truncate` 通过文件路径对文件进行截断。

#### 函数原型
```c
#include <unistd.h>

int truncate(const char *pathname, off_t length);
```

- **参数**：
  - `pathname`：文件路径。
  - `length`：文件截断后的目标大小（以字节为单位）。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    // 将文件截断为 100 字节
    if (truncate(filename, 100) == 0) {
        printf("File truncated successfully\n");
    } else {
        perror("truncate");
    }

    return 0;
}
```

### 2. `ftruncate` 系统调用

`ftruncate` 是基于文件描述符的截断操作，文件需先打开。

#### 函数原型
```c
#include <unistd.h>

int ftruncate(int fd, off_t length);
```

- **参数**：
  - `fd`：文件描述符。
  - `length`：文件截断后的目标大小。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    int fd = open("test.txt", O_RDWR);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    // 将文件截断为 100 字节
    if (ftruncate(fd, 100) == 0) {
        printf("File truncated successfully\n");
    } else {
        perror("ftruncate");
    }

    close(fd);
    return 0;
}
```

### 注意事项

1. **权限**：调用`truncate`或`ftruncate`时，通常需要对文件具有写权限，否则会失败。
2. **文件增长**：如果目标长度大于当前文件大小，文件会增长，新增部分用空字节填充。
3. **文件缩小**：如果目标长度小于当前文件大小，文件会被裁剪，多余的数据被丢弃。

### 适用场景

- **清空文件内容**：可以将文件大小设置为 `0`，以便清空文件内容。
- **文件扩展**：用于预分配文件大小，例如创建一个空白的大文件。

## 9.文件长度

在Linux系统中，可以通过多种方法获取文件长度（即文件大小），包括使用`stat`、`fstat`、`lseek`等系统调用。以下是几种常用的方法：

### 1. 使用 `stat` 获取文件大小

`stat` 系统调用可以获取文件的元数据，包括文件大小。

#### 函数原型
```c
#include <sys/stat.h>
int stat(const char *pathname, struct stat *buf);
```

- **文件大小**存储在 `stat` 结构体的 `st_size` 字段中，以字节为单位。

#### 示例代码
```c
#include <sys/stat.h>
#include <stdio.h>

int main() {
    struct stat buf;
    if (stat("test.txt", &buf) == 0) {
        printf("File size: %ld bytes\n", buf.st_size);
    } else {
        perror("stat");
    }
    return 0;
}
```

### 2. 使用 `fstat` 获取文件大小

`fstat` 类似于 `stat`，但它通过文件描述符获取文件大小。

#### 函数原型
```c
#include <sys/stat.h>
int fstat(int fd, struct stat *buf);
```

- 文件大小依然保存在 `stat` 结构体的 `st_size` 字段中。

#### 示例代码
```c
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    int fd = open("test.txt", O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    struct stat buf;
    if (fstat(fd, &buf) == 0) {
        printf("File size: %ld bytes\n", buf.st_size);
    } else {
        perror("fstat");
    }

    close(fd);
    return 0;
}
```

### 3. 使用 `lseek` 获取文件大小

`lseek` 可用于移动文件指针，利用它将文件指针移动到文件末尾可以获取文件大小。

#### 函数原型
```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

- `whence` 参数设为 `SEEK_END` 表示从文件末尾开始偏移，这样 `lseek` 返回的偏移量就是文件大小。

#### 示例代码
```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd = open("test.txt", O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    // 将文件指针移到文件末尾，以获取文件大小
    off_t file_size = lseek(fd, 0, SEEK_END);
    if (file_size != -1) {
        printf("File size: %ld bytes\n", file_size);
    } else {
        perror("lseek");
    }

    close(fd);
    return 0;
}
```

### 4. 使用 `ftell` 获取文件大小（标准C库函数）

`ftell` 也是一种获取文件大小的标准C库函数，通常在 `FILE *` 类型的文件流中使用。

#### 函数原型
```c
#include <stdio.h>
long ftell(FILE *stream);
```

#### 示例代码
```c
#include <stdio.h>

int main() {
    FILE *file = fopen("test.txt", "rb");
    if (!file) {
        perror("fopen");
        return 1;
    }

    // 将文件指针移到文件末尾
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    printf("File size: %ld bytes\n", file_size);

    fclose(file);
    return 0;
}
```

### 方法总结

| 方法         | 使用场景                      | 描述                                  |
|--------------|-------------------------------|---------------------------------------|
| `stat`       | 基于文件路径获取文件大小       | 适合一般的文件大小查询               |
| `fstat`      | 基于文件描述符获取文件大小     | 适合文件已打开的情况下查询大小       |
| `lseek`      | 基于文件描述符获取文件大小     | 使用文件指针的偏移量                 |
| `ftell`      | 基于 `FILE *` 获取文件大小    | 标准C库函数，常用于文件流            |

## 10.粘着位

在Linux文件系统中，**粘着位（Sticky Bit）** 是一种特殊的权限位，用于目录的访问控制。粘着位的主要作用是在共享目录中，防止非所有者用户删除或修改其他用户的文件。

### 粘着位的作用

- 当粘着位设置在目录上时，只有以下用户可以删除或重命名该目录中的文件：
  - 文件的所有者
  - 目录的所有者
  - 超级用户（root）

  这样可以在多用户环境下保护文件不被其他用户误删。粘着位常用在 `/tmp` 等公共目录中，以避免其他用户删除不属于自己的文件。

### 设置粘着位

粘着位的八进制标记是 **`1`**，即在权限数字最左侧加上一个 `1` 就可以设置粘着位。例如：
- `1755`：设置粘着位，并设置权限为 `755`。
- `1777`：设置粘着位，目录权限为 `777`（这种权限在 `/tmp` 目录常见）。

### 示例

#### 使用 `chmod` 设置粘着位

可以使用八进制模式或符号模式设置粘着位。

1. **八进制模式**：
   ```bash
   chmod 1777 /path/to/directory
   ```

2. **符号模式**：`+t` 表示设置粘着位，`-t` 表示取消粘着位。
   ```bash
   chmod +t /path/to/directory
   ```

#### 检查粘着位

使用 `ls -ld` 命令查看目录的权限。如果权限字符串的最后一个字符为 `t`，则表示设置了粘着位。例如：

```bash
$ ls -ld /tmp
drwxrwxrwt  10 root  root  4096 Nov 11 13:00 /tmp
```

其中，`drwxrwxrwt` 的最后一个 `t` 表示 `/tmp` 目录启用了粘着位。

### 在C语言中设置粘着位

可以使用 `chmod`、`fchmod`、`fchmodat` 等函数，通过指定 `S_ISVTX` 常量来设置粘着位。

```c
#include <sys/stat.h>
#include <stdio.h>

int main() {
    const char *directory = "./mydir";

    // 设置权限为 1777（即 0777 + 粘着位）
    if (chmod(directory, 0777 | S_ISVTX) == 0) {
        printf("Sticky bit set successfully\n");
    } else {
        perror("chmod");
    }

    return 0;
}
```

在代码中，`S_ISVTX` 是粘着位的宏定义，通过按位或操作来设置文件或目录的权限。

## 11.link,linkat,unlink,unlinkat,remove

在Linux系统中，`link`、`linkat`、`unlink`、`unlinkat`、`remove`等函数提供了对文件链接和删除的操作。它们主要用于创建硬链接以及删除文件或目录。

### 1. `link` 系统调用

`link` 创建一个新的硬链接，使新链接路径和原文件路径指向同一个文件数据（即它们有相同的inode）。

#### 函数原型
```c
#include <unistd.h>

int link(const char *oldpath, const char *newpath);
```

- **参数**：
  - `oldpath`：原文件路径。
  - `newpath`：新链接路径。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *source = "test.txt";
    const char *linkname = "test_link.txt";

    // 创建一个硬链接
    if (link(source, linkname) == 0) {
        printf("Link created successfully\n");
    } else {
        perror("link");
    }

    return 0;
}
```

### 2. `linkat` 系统调用

`linkat` 是 `link` 的增强版，可以在不同目录文件描述符间创建硬链接，具有更高的灵活性。

#### 函数原型
```c
#include <unistd.h>

int linkat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags);
```

- **参数**：
  - `olddirfd`：原文件所在目录的文件描述符。使用 `AT_FDCWD` 表示当前目录。
  - `oldpath`：原文件路径。
  - `newdirfd`：新链接所在目录的文件描述符。
  - `newpath`：新链接路径。
  - `flags`：标志位，目前只支持 `AT_SYMLINK_FOLLOW`，表示跟随符号链接。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    const char *source = "test.txt";
    const char *linkname = "test_link.txt";

    // 使用当前目录作为基准目录创建硬链接
    if (linkat(AT_FDCWD, source, AT_FDCWD, linkname, 0) == 0) {
        printf("Link created successfully\n");
    } else {
        perror("linkat");
    }

    return 0;
}
```

### 3. `unlink` 系统调用

`unlink` 用于删除文件。它会删除指定路径上的文件名，但文件数据只会在最后一个链接被删除时才会释放。

#### 函数原型
```c
#include <unistd.h>

int unlink(const char *pathname);
```

- **参数**：
  - `pathname`：要删除的文件路径。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *filename = "test_link.txt";

    // 删除文件
    if (unlink(filename) == 0) {
        printf("File unlinked successfully\n");
    } else {
        perror("unlink");
    }

    return 0;
}
```

### 4. `unlinkat` 系统调用

`unlinkat` 是 `unlink` 的增强版，可以在目录文件描述符基础上执行删除操作，并且支持删除目录（通过设置标志位）。

#### 函数原型
```c
#include <unistd.h>

int unlinkat(int dirfd, const char *pathname, int flags);
```

- **参数**：
  - `dirfd`：文件所在目录的文件描述符。使用 `AT_FDCWD` 表示当前目录。
  - `pathname`：要删除的文件路径。
  - `flags`：
    - `0`：表示删除文件。
    - `AT_REMOVEDIR`：表示删除目录。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    const char *filename = "test_link.txt";

    // 使用当前目录作为基准目录删除文件
    if (unlinkat(AT_FDCWD, filename, 0) == 0) {
        printf("File unlinked successfully\n");
    } else {
        perror("unlinkat");
    }

    return 0;
}
```

### 5. `remove` 函数

`remove` 是标准C库函数，用于删除文件或目录，它会自动判断路径是文件还是目录，并执行相应的删除操作。

#### 函数原型
```c
#include <stdio.h>

int remove(const char *pathname);
```

- **参数**：
  - `pathname`：要删除的文件或目录路径。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1`。

#### 示例代码
```c
#include <stdio.h>

int main() {
    const char *filename = "test.txt";

    // 删除文件或目录
    if (remove(filename) == 0) {
        printf("File or directory removed successfully\n");
    } else {
        perror("remove");
    }

    return 0;
}
```

### 总结

| 函数       | 主要功能             | 支持目录 | 参数描述                               |
|------------|----------------------|----------|----------------------------------------|
| `link`     | 创建硬链接           | 否       | 基于文件路径                           |
| `linkat`   | 创建硬链接           | 否       | 支持文件描述符、跟随符号链接选项       |
| `unlink`   | 删除文件             | 否       | 基于文件路径                           |
| `unlinkat` | 删除文件或目录       | 是       | 支持文件描述符，可选择删除目录         |
| `remove`   | 删除文件或目录       | 是       | 标准C库函数，自动判断文件或目录类型    |


## 12.rename,renameat

在Linux系统中，`rename`和`renameat`函数用于重命名或移动文件和目录。它们可以将文件或目录从一个路径移动到另一个路径，甚至可以跨目录操作。

### 1. `rename` 系统调用

`rename` 用于在同一文件系统内重命名或移动文件或目录。若目标路径已存在，`rename` 会先删除目标路径的文件或目录，然后执行重命名操作。

#### 函数原型
```c
#include <stdio.h>

int rename(const char *oldpath, const char *newpath);
```

- **参数**：
  - `oldpath`：文件或目录的当前路径。
  - `newpath`：文件或目录的新路径。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <stdio.h>

int main() {
    const char *oldname = "oldname.txt";
    const char *newname = "newname.txt";

    // 重命名文件
    if (rename(oldname, newname) == 0) {
        printf("File renamed successfully\n");
    } else {
        perror("rename");
    }

    return 0;
}
```

### 2. `renameat` 系统调用

`renameat` 是 `rename` 的增强版，允许使用文件描述符来指定文件的源目录和目标目录。它非常适用于需要使用文件描述符的应用场景，例如沙盒环境或基于文件描述符的目录操作。

#### 函数原型
```c
#include <fcntl.h>
#include <unistd.h>

int renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath);
```

- **参数**：
  - `olddirfd`：旧路径所在目录的文件描述符。使用 `AT_FDCWD` 表示当前目录。
  - `oldpath`：文件或目录的当前路径。
  - `newdirfd`：新路径所在目录的文件描述符。
  - `newpath`：文件或目录的新路径。

- **返回值**：
  - 成功返回 `0`，失败返回 `-1` 并设置 `errno`。

#### 示例代码
```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *oldname = "oldname.txt";
    const char *newname = "newname.txt";

    // 使用当前目录作为基准目录重命名文件
    if (renameat(AT_FDCWD, oldname, AT_FDCWD, newname) == 0) {
        printf("File renamed successfully\n");
    } else {
        perror("renameat");
    }

    return 0;
}
```

### 注意事项

1. **跨文件系统**：`rename` 和 `renameat` 不支持跨文件系统的移动。若两个路径不在同一文件系统，调用会失败。
2. **目标路径存在**：如果目标路径存在且为文件，则会被删除并替换；如果为非空目录，操作会失败。
3. **权限**：调用者需要对 `oldpath` 和 `newpath` 都具有适当的权限，否则操作会失败。

### 总结

| 函数       | 主要功能            | 描述                              |
|------------|---------------------|-----------------------------------|
| `rename`   | 重命名或移动文件    | 基于路径，适合简单的重命名操作    |
| `renameat` | 重命名或移动文件    | 基于文件描述符，适合高级操作需求 |

## 13.符号链接

符号链接（Symbolic Link，也称软链接）在Linux系统中是一个特殊类型的文件，它指向另一个文件或目录。符号链接类似于Windows系统中的快捷方式，可以让多个路径指向同一个目标文件或目录。与硬链接不同，符号链接是一个独立的文件，具有自己的inode，并且可以跨文件系统使用。

### 创建符号链接

Linux系统中可以使用`symlink`和`symlinkat`系统调用来创建符号链接。

#### 1. `symlink` 系统调用

`symlink`用于创建符号链接，使指定的路径指向目标文件或目录。

##### 函数原型
```c
#include <unistd.h>

int symlink(const char *target, const char *linkpath);
```

- **参数**：
  - `target`：目标文件或目录的路径。
  - `linkpath`：符号链接的路径。

- **返回值**：
  - 成功返回`0`，失败返回`-1`并设置`errno`。

##### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *target = "original_file.txt";
    const char *linkpath = "symbolic_link.txt";

    // 创建符号链接
    if (symlink(target, linkpath) == 0) {
        printf("Symbolic link created successfully\n");
    } else {
        perror("symlink");
    }

    return 0;
}
```

#### 2. `symlinkat` 系统调用

`symlinkat`是`symlink`的增强版，可以在指定目录的文件描述符基础上创建符号链接。

##### 函数原型
```c
#include <unistd.h>

int symlinkat(const char *target, int newdirfd, const char *linkpath);
```

- **参数**：
  - `target`：目标文件或目录的路径。
  - `newdirfd`：符号链接所在目录的文件描述符。使用`AT_FDCWD`表示当前目录。
  - `linkpath`：符号链接的路径。

- **返回值**：
  - 成功返回`0`，失败返回`-1`并设置`errno`。

##### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    const char *target = "original_file.txt";
    const char *linkpath = "symbolic_link.txt";

    // 在当前目录创建符号链接
    if (symlinkat(target, AT_FDCWD, linkpath) == 0) {
        printf("Symbolic link created successfully\n");
    } else {
        perror("symlinkat");
    }

    return 0;
}
```

### 读取符号链接

符号链接本身是一个指向目标文件的路径，要读取它所指向的内容，可以使用`readlink`和`readlinkat`函数。

#### 1. `readlink` 系统调用

`readlink`用于读取符号链接的内容，即符号链接所指向的路径。

##### 函数原型
```c
#include <unistd.h>

ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);
```

- **参数**：
  - `pathname`：符号链接的路径。
  - `buf`：存放读取内容的缓冲区。
  - `bufsiz`：缓冲区大小。

- **返回值**：
  - 返回读取的字节数，失败返回`-1`并设置`errno`。

##### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *linkpath = "symbolic_link.txt";
    char buf[1024];

    // 读取符号链接内容
    ssize_t len = readlink(linkpath, buf, sizeof(buf) - 1);
    if (len != -1) {
        buf[len] = '\0';  // 确保字符串以空字符结尾
        printf("Symbolic link points to: %s\n", buf);
    } else {
        perror("readlink");
    }

    return 0;
}
```

#### 2. `readlinkat` 系统调用

`readlinkat` 是`readlink`的增强版，可以在指定目录的文件描述符下读取符号链接内容。

##### 函数原型
```c
#include <unistd.h>

ssize_t readlinkat(int dirfd, const char *pathname, char *buf, size_t bufsiz);
```

- **参数**：
  - `dirfd`：符号链接所在目录的文件描述符。使用`AT_FDCWD`表示当前目录。
  - `pathname`：符号链接的路径。
  - `buf`：存放读取内容的缓冲区。
  - `bufsiz`：缓冲区大小。

- **返回值**：
  - 返回读取的字节数，失败返回`-1`并设置`errno`。

##### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    const char *linkpath = "symbolic_link.txt";
    char buf[1024];

    // 在当前目录读取符号链接内容
    ssize_t len = readlinkat(AT_FDCWD, linkpath, buf, sizeof(buf) - 1);
    if (len != -1) {
        buf[len] = '\0';  // 确保字符串以空字符结尾
        printf("Symbolic link points to: %s\n", buf);
    } else {
        perror("readlinkat");
    }

    return 0;
}
```

### 删除符号链接

删除符号链接可以使用`unlink`或`unlinkat`，操作与删除普通文件类似。

### 总结

| 函数          | 功能                         | 描述                              |
|---------------|------------------------------|-----------------------------------|
| `symlink`     | 创建符号链接                 | 使用路径创建符号链接              |
| `symlinkat`   | 创建符号链接                 | 基于文件描述符创建符号链接        |
| `readlink`    | 读取符号链接内容             | 返回符号链接指向的目标路径        |
| `readlinkat`  | 读取符号链接内容             | 基于文件描述符读取符号链接内容    |
| `unlink`      | 删除符号链接或文件           | 符号链接删除操作与普通文件相同    |
| `unlinkat`    | 删除符号链接或文件或目录     | 支持文件描述符，并可删除目录      |

## 14.文件的时间

在Linux系统中，每个文件或目录都关联着一组时间戳，用于记录该文件的不同操作时间。主要有以下三种时间戳：

1. **访问时间（Access Time，`atime`）**：文件或目录最后一次被访问的时间。例如，`cat`命令查看文件内容时会更新`atime`。
2. **修改时间（Modification Time，`mtime`）**：文件内容最后一次被修改的时间。例如，使用`echo`命令将新内容写入文件会更新`mtime`。
3. **状态更改时间（Change Time，`ctime`）**：文件的元数据（如权限、所有者等）最后一次被修改的时间。例如，使用`chmod`更改文件权限会更新`ctime`。


## 15.futimens,utimensat,utimes

在Linux系统中，`futimens`、`utimensat`和`utimes`系统调用可以用于修改文件的时间戳。它们各有不同的功能和适用场景，支持对文件的访问时间（`atime`）和修改时间（`mtime`）进行高精度修改。

### 1. `utimensat` 系统调用

`utimensat`是`utime`的增强版本，支持纳秒级别的时间设置，并可以通过文件描述符指定文件路径（支持操作符号链接、相对目录路径等）。

#### 函数原型
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <time.h>

int utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags);
```

- **参数**：
  - `dirfd`：目录文件描述符。使用`AT_FDCWD`表示当前工作目录。
  - `pathname`：文件路径。
  - `times`：一个`timespec`数组，包含两个元素，用于指定`atime`和`mtime`。
    - `times[0]`：访问时间（`atime`）。
    - `times[1]`：修改时间（`mtime`）。
    - 如果`times`为`NULL`，则文件时间戳会被设置为当前时间。
  - `flags`：可以使用`AT_SYMLINK_NOFOLLOW`避免跟随符号链接。

- **返回值**：成功返回`0`，失败返回`-1`并设置`errno`。

#### 示例代码
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>

int main() {
    const char *filename = "example.txt";
    struct timespec times[2];

    times[0].tv_sec = time(NULL);   // 设置访问时间为当前时间
    times[0].tv_nsec = 0;
    times[1].tv_sec = time(NULL);   // 设置修改时间为当前时间
    times[1].tv_nsec = 0;

    if (utimensat(AT_FDCWD, filename, times, 0) == -1) {
        perror("utimensat");
        return 1;
    }

    printf("File times updated successfully\n");
    return 0;
}
```

### 2. `futimens` 系统调用

`futimens`类似于`utimensat`，但直接接受一个文件描述符，因此通常用于已打开的文件上操作时间戳。

#### 函数原型
```c
#include <sys/stat.h>
#include <time.h>

int futimens(int fd, const struct timespec times[2]);
```

- **参数**：
  - `fd`：文件描述符，指定要操作的文件。
  - `times`：一个`timespec`数组，包含两个元素，用于指定`atime`和`mtime`。
    - `times[0]`：访问时间（`atime`）。
    - `times[1]`：修改时间（`mtime`）。
    - 如果`times`为`NULL`，则文件时间戳会被设置为当前时间。

- **返回值**：成功返回`0`，失败返回`-1`并设置`errno`。

#### 示例代码
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>

int main() {
    int fd = open("example.txt", O_RDWR);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    struct timespec times[2];
    times[0].tv_sec = time(NULL);  // 设置访问时间为当前时间
    times[0].tv_nsec = 0;
    times[1].tv_sec = time(NULL);  // 设置修改时间为当前时间
    times[1].tv_nsec = 0;

    if (futimens(fd, times) == -1) {
        perror("futimens");
        close(fd);
        return 1;
    }

    printf("File times updated successfully\n");
    close(fd);
    return 0;
}
```

### 3. `utimes` 系统调用

`utimes`是较旧的系统调用，用于以微秒精度修改文件时间戳。与`utimensat`和`futimens`不同的是，它使用`timeval`结构，并且不支持纳秒级精度。

#### 函数原型
```c
#include <sys/time.h>

int utimes(const char *filename, const struct timeval times[2]);
```

- **参数**：
  - `filename`：文件路径。
  - `times`：一个`timeval`数组，包含两个元素，用于指定`atime`和`mtime`。
    - `times[0]`：访问时间（`atime`）。
    - `times[1]`：修改时间（`mtime`）。
    - 如果`times`为`NULL`，则文件时间戳会被设置为当前时间。

- **返回值**：成功返回`0`，失败返回`-1`并设置`errno`。

#### 示例代码
```c
#include <sys/time.h>
#include <stdio.h>

int main() {
    const char *filename = "example.txt";
    struct timeval times[2];

    times[0].tv_sec = time(NULL);    // 设置访问时间为当前时间
    times[0].tv_usec = 0;
    times[1].tv_sec = time(NULL);    // 设置修改时间为当前时间
    times[1].tv_usec = 0;

    if (utimes(filename, times) == -1) {
        perror("utimes");
        return 1;
    }

    printf("File times updated successfully\n");
    return 0;
}
```

### 总结

| 函数       | 精度      | 使用场景                            | 支持结构        |
|------------|-----------|-------------------------------------|-----------------|
| `utimensat`| 纳秒      | 可操作符号链接、指定相对路径        | `timespec`数组  |
| `futimens` | 纳秒      | 已打开文件的文件描述符              | `timespec`数组  |
| `utimes`   | 微秒      | 基于文件路径，不支持符号链接和纳秒精度 | `timeval`数组  |

- **`utimensat`**：更灵活，可以对符号链接进行操作。
- **`futimens`**：适合用于已打开的文件描述符。
- **`utimes`**：用于微秒精度的时间戳操作，不支持纳秒级。

## 16.mkdir,mkdirat,rmdir

在Linux中，`mkdir`、`mkdirat`和`rmdir`是与目录创建和删除相关的系统调用。它们允许程序操作文件系统中的目录。下面是这三个函数的详细介绍。

### 1. `mkdir` 系统调用

`mkdir`用于创建一个新的目录。该目录的权限由`mode`参数指定。

#### 函数原型
```c
#include <sys/stat.h>

int mkdir(const char *pathname, mode_t mode);
```

- **参数**：
  - `pathname`：要创建的目录的路径。
  - `mode`：新目录的权限掩码（通常使用`S_IRWXU`、`S_IRWXG`、`S_IRWXO`等值来指定权限）。
  
- **返回值**：
  - 成功时返回`0`，失败时返回`-1`并设置`errno`。

- **常用权限说明**：
  - `S_IRWXU`：用户读、写、执行权限
  - `S_IRWXG`：组读、写、执行权限
  - `S_IRWXO`：其他用户读、写、执行权限

#### 示例代码
```c
#include <sys/stat.h>
#include <stdio.h>

int main() {
    const char *dirname = "new_directory";

    // 创建目录，权限为775
    if (mkdir(dirname, 0775) == -1) {
        perror("mkdir");
        return 1;
    }

    printf("Directory created successfully\n");
    return 0;
}
```

### 2. `mkdirat` 系统调用

`mkdirat`与`mkdir`功能相似，但它允许使用文件描述符（`dirfd`）来指定目录路径，允许在相对路径上创建目录，通常与`open`函数配合使用。

#### 函数原型
```c
#include <fcntl.h>
#include <sys/stat.h>

int mkdirat(int dirfd, const char *pathname, mode_t mode);
```

- **参数**：
  - `dirfd`：目录文件描述符，表示相对目录的基准路径。如果使用`AT_FDCWD`，表示当前工作目录。
  - `pathname`：要创建的目录的相对路径。
  - `mode`：新目录的权限掩码。

- **返回值**：
  - 成功时返回`0`，失败时返回`-1`并设置`errno`。

#### 示例代码
```c
#include <fcntl.h>
#include <sys/stat.h>
#include <stdio.h>

int main() {
    const char *dirname = "new_directory";
    int dirfd = open(".", O_RDONLY);  // 打开当前目录

    // 在当前目录下创建一个新目录
    if (mkdirat(dirfd, dirname, 0775) == -1) {
        perror("mkdirat");
        close(dirfd);
        return 1;
    }

    printf("Directory created successfully\n");
    close(dirfd);
    return 0;
}
```

`mkdirat`函数的优势在于它允许指定相对路径，并且可以基于文件描述符操作文件或目录。这对于操作挂载点或需要不同文件描述符的场景非常有用。

### 3. `rmdir` 系统调用

`rmdir`用于删除空目录。如果目录不是空的，调用会失败。

#### 函数原型
```c
#include <stdio.h>

int rmdir(const char *pathname);
```

- **参数**：
  - `pathname`：要删除的目录路径。
  
- **返回值**：
  - 成功时返回`0`，失败时返回`-1`并设置`errno`。

#### 示例代码
```c
#include <stdio.h>

int main() {
    const char *dirname = "new_directory";

    // 删除目录
    if (rmdir(dirname) == -1) {
        perror("rmdir");
        return 1;
    }

    printf("Directory removed successfully\n");
    return 0;
}
```

`rmdir`只能删除空目录。如果目录中包含文件或子目录，调用将返回错误。

### 总结

| 函数名    | 功能                                      | 参数        | 特点                                        |
|-----------|-------------------------------------------|-------------|---------------------------------------------|
| `mkdir`   | 创建目录                                  | `pathname`, `mode`  | 创建一个目录，指定权限                     |
| `mkdirat` | 相对于文件描述符创建目录                  | `dirfd`, `pathname`, `mode` | 可以在相对路径上创建目录，支持使用文件描述符 |
| `rmdir`   | 删除空目录                                | `pathname`  | 删除一个空目录，失败时返回错误             |

- **`mkdirat`**：支持相对路径和文件描述符，用于更灵活的目录创建操作。
- **`rmdir`**：只能删除空目录。

## 17.读目录



## 18.chdir,fchdir,getcwd

在Linux中，`chdir`、`fchdir`和`getcwd`是与当前工作目录（CWD，Current Working Directory）相关的系统调用。它们允许程序更改或获取当前工作目录，当前工作目录是进程上下文中的一个重要概念，许多文件路径操作都是基于当前工作目录的。

### 1. `chdir` 系统调用

`chdir`用于更改当前进程的工作目录。新的工作目录由`pathname`指定。

#### 函数原型
```c
#include <unistd.h>

int chdir(const char *pathname);
```

- **参数**：
  - `pathname`：要设置为新的工作目录的路径。路径可以是绝对路径或相对路径。
  
- **返回值**：
  - 成功时返回`0`，失败时返回`-1`并设置`errno`。

#### 示例代码
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    const char *new_directory = "/home/user";  // 新工作目录

    if (chdir(new_directory) == -1) {
        perror("chdir");
        return 1;
    }

    printf("Changed directory to %s\n", new_directory);
    return 0;
}
```

### 2. `fchdir` 系统调用

`fchdir`与`chdir`类似，但它接受一个文件描述符作为参数，而不是路径。这使得`fchdir`可以使用已打开文件的文件描述符来更改工作目录。

#### 函数原型
```c
#include <unistd.h>

int fchdir(int fd);
```

- **参数**：
  - `fd`：一个有效的文件描述符，指向要切换到的目录。可以使用`open`打开目录文件并获取文件描述符。
  
- **返回值**：
  - 成功时返回`0`，失败时返回`-1`并设置`errno`。

#### 示例代码
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    const char *directory = "/home/user";  // 目标目录
    int fd = open(directory, O_RDONLY | O_DIRECTORY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    if (fchdir(fd) == -1) {
        perror("fchdir");
        close(fd);
        return 1;
    }

    printf("Changed directory to %s using fchdir\n", directory);
    close(fd);
    return 0;
}
```

### 3. `getcwd` 系统调用

`getcwd`用于获取当前工作目录的绝对路径。它将当前工作目录的路径存储到由`buf`指向的缓冲区中。

#### 函数原型
```c
#include <unistd.h>

char *getcwd(char *buf, size_t size);
```

- **参数**：
  - `buf`：一个字符数组，用于存储当前工作目录的路径。
  - `size`：`buf`缓冲区的大小。如果缓冲区太小，`getcwd`会返回`NULL`，并将`errno`设置为`ERANGE`（路径太长）。
  
- **返回值**：
  - 成功时返回`buf`（即目录路径），失败时返回`NULL`并设置`errno`。

#### 示例代码
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    char *cwd = getcwd(NULL, 0);  // 获取当前工作目录

    if (cwd == NULL) {
        perror("getcwd");
        return 1;
    }

    printf("Current working directory: %s\n", cwd);
    free(cwd);  // 释放getcwd分配的内存
    return 0;
}
```

### 总结

| 函数名   | 功能                                    | 参数                          | 特点                            |
|----------|-----------------------------------------|-------------------------------|---------------------------------|
| `chdir`  | 更改当前工作目录                       | `pathname`                    | 使用路径更改进程的工作目录     |
| `fchdir` | 通过文件描述符更改当前工作目录         | `fd`（文件描述符）            | 通过已打开目录的文件描述符更改 |
| `getcwd` | 获取当前工作目录的绝对路径            | `buf`, `size`                  | 获取当前工作目录并返回路径    |

- **`chdir`**：直接使用路径来修改工作目录。
- **`fchdir`**：通过文件描述符来修改工作目录，适用于已经打开的目录。
- **`getcwd`**：获取当前工作目录的路径。
