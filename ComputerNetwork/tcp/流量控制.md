# 流量控制

## 1. 流量控制

> **定义**：TCP 流量控制是接收端通过通告 `接收窗口（rwnd）` 告诉发送端：  
> “我当前还能接收这么多数据，你别发太快。”

这是一种 **端到端的控制机制**，防止因接收方处理不过来导致丢包或 buffer 溢出。

---

## 2. 关键变量与原理

### `rwnd`（Receive Window）- 接收窗口

- 接收端维护的一个变量
- 告诉发送端：我这边 buffer 还能接收多少数据
- 每次 TCP 报文里都会携带（在 TCP 头部字段里）

### `snd_wnd`（Send Window）- 实际发送窗口

发送方实际可以发送的数据量：

```
sendable = min(cwnd, rwnd)
```

**`cwnd` 控制网络拥塞，`rwnd` 控制接收能力**

---


---

## 3. 零窗口（Zero Window）

- 如果接收端的 `rwnd = 0`，发送方不能再发送新数据（会阻塞住）
- 为了避免“永远阻塞”，**TCP 会周期性发送 `window probe`（窗口探测报文）**

```text
→ 发送方每隔 200ms, 400ms, 800ms... 发送一个 1 字节包，测试窗口是否打开
```

---

## 4. 典型调优相关的系统参数（Linux）

```bash

# 系统默认最大接收窗口
sysctl net.ipv4.tcp_rmem

# 系统默认最大发送窗口
sysctl net.ipv4.tcp_wmem
```

值一般是 3 个整数：
```
min default max
```

例如：
```bash

net.ipv4.tcp_rmem = 4096 87380 16777216
```

---

## 5. 流量控制 vs 拥塞控制

| 特性             | 流量控制                        | 拥塞控制                     |
|------------------|----------------------------------|-------------------------------|
| 控制目标         | 防止接收端被压垮               | 防止网络本身拥堵             |
| 控制变量         | rwnd                            | cwnd、ssthresh               |
| 控制一端/两端     | 端到端（接收端通知发送端）       | 发送端自己估计               |
| 响应方式         | 通告窗口大小                    | ACK 判断、丢包判断           |

---

## 6. 常见问题

### 为什么发送方明明没发送满，还是阻塞了？
- 接收端的 `rwnd` 变成了 0
- 或者是 `rwnd < MSS`，导致发送端不能继续发送

### 如何模拟 rwnd 为 0 的情况？
可以写一个接收端服务一直不 `recv()`，模拟“接收缓冲区被打满”的情形。

---
